<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Demo WebApp</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <style>
        .rocket.launch {
            animation: launchRocket 4s forwards;
        }

        @keyframes launchRocket {
            0% {
                transform: translate(0, 0) rotate(0deg);
            }
            100% {
                transform: translate(700px, -500px) rotate(45deg);
            }
        }

        .loading-circle {
            border: 8px solid var(--border-color);
            border-top: 8px solid var(--button-color);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            display: none;
            margin-left: 10px;
        }

        .loading-circle-left {
            margin-right: 10px;
            margin-left: 0;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .training-params {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .training-params input {
            width: 100px;
            padding: 5px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }
        
        .training-params label {
            color: var(--text-color);
            font-weight: bold;
        }

        .form-select {
            width: 200px;
            padding: 5px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: white;
            color: var(--text-color);
        }

        .applications-checklist {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        .application-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .application-item input[type="checkbox"] {
            margin: 0;
        }

        .application-item label {
            color: var(--text-color);
            font-size: 14px;
        }

        .config-section {
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .config-group {
            border: 1px solid var(--border-color);
            padding: 15px;
            border-radius: 4px;
        }

        .config-group h3 {
            margin-top: 0;
            color: var(--text-color);
            font-size: 1.1em;
            margin-bottom: 15px;
        }

        .select-container {
            margin-bottom: 15px;
        }

        .select-container label {
            color: var(--text-color);
            font-weight: bold;
        }

        .select-container input {
            width: 100px;
            padding: 5px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        .loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .loading-overlay .loading-circle {
            display: block;
        }

        .config-row {
            display: flex;
            gap: 20px;
        }

        .instructions-summary-box {
            border: 1px solid var(--border-color);
            padding: 15px;
            border-radius: 4px;
            background-color: #f9f9f9;
            margin-bottom: 20px;
        }

        #realTimeRenderDisplay {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: #f9f9f9;
            text-align: center; /* Center the image and title */
        }

        #realTimeRenderDisplay img {
            max-width: 100%;
            max-height: 400px; /* Adjust as needed */
            border: 1px solid var(--border-color);
            margin-bottom: 10px;
        }

        #realTimeRenderDisplay h4 {
            color: var(--text-color);
            margin-top: 0;
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-circle"></div>
    </div>
    <div class="container">
        <div class="box shadow-effect">
            <div class="tabs">
                <div class="tab-buttons">
                    <button class="tab-btn" onclick="openTab(event, 'setupTab')">Application</button>
                    <button class="tab-btn" onclick="openTab(event, 'configTab')">Config</button>
                    <button class="tab-btn active" onclick="openTab(event, 'inputTab')">Instruction Input</button>
                    <button class="tab-btn" onclick="openTab(event, 'trainModelTab')">Train Model</button>
                    <button class="tab-btn" onclick="openTab(event, 'resultsTab')">Results</button>
                </div>
                <div class="tab-text">
                    See <a href="https://elsci.org">elsci.org</a> for more information 
                    <a href="https://elsci.org"><img src="https://github.com/pdfosborne/elsciRL-Wiki/blob/main/Resources/images/elsciRL_logo_owl_cropped.png?raw=true" alt="elsciRL-Logo" style="width:24px;height:24px;"></a>  
                </div>
                
            </div>
            <div id="setupTab" class="tab-content" style="display:none;">
                <div class="config-section" style="width: 95%;">
                    <div class="config-row" style="display: flex; flex-wrap: wrap; gap: 20px;">
                        <div class="config-group" style="flex: 1;">
                            <h3>Applications</h3>
                            <div class="select-container">
                                <label for="applicationSelect">Select Application:</label>
                                <select id="applicationSelect" class="form-select" required>
                                    <!-- Remove the initial option here -->
                                </select>
                            </div>
                            <div id="configSelections" style="display: none;">
                                <div class="training-params">
                                    <label for="localConfigSelect">Local Config:</label>
                                    <select id="localConfigSelect" class="form-select">
                                        <option value="" disabled selected>Choose config...</option>
                                    </select>
                                </div>
                                <div class="training-params">
                                    <label for="observedStateSelect">Observed State Input:</label>
                                    <select id="observedStateSelect" class="form-select">
                                        <!-- Options will be populated dynamically -->
                                    </select>
                                </div>
                                <div class="training-params">
                                    <label for="plotSelect">Select Analysis File:</label>
                                    <select id="plotSelect" class="form-select">
                                        <option value="" disabled selected>Choose plot...</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        <div id="prerenderImageContainer" class="image-section shadow-effect" style="flex: 1;">
                            <div class="select-container">
                                <label for="prerenderImageSelect">Select Preview Image:</label>
                                <select id="prerenderImageSelect" class="form-select">
                                    <!-- Options will be populated dynamically -->
                                </select>
                            </div>
                            <img id="prerenderImage" class="shadow-effect" style="display: none;">
                        </div>
                    </div>
                </div>
            </div>
            <div id="configTab" class="tab-content" style="display:none;">
                <div class="config-section" style="width: 95%;">
                    <!-- Add experiment config selection at the top -->
                    <div class="config-group" style="margin-bottom: 20px;">
                        <h3>Experiment Configuration</h3>
                        <div class="select-container">
                            <label for="experimentConfigSelect">Select Experiment Config:</label>
                            <select id="experimentConfigSelect" class="form-select">
                                <option value="" disabled selected>Choose experiment config...</option>
                            </select>
                        </div>
                    </div>

                    <div class="config-row" style="display: flex; flex-wrap: wrap; gap: 20px;">
                        <div class="config-group" style="flex: 1;">
                            <h3>Agent Type</h3>
                            <!-- TODO: DEFINE AGENTS THAT ARE READY, UNCHECK SO PARAMTERS SHOWS WHEN CHECKED -->
                            <div class="applications-checklist">
                                <div class="application-item">
                                    <input type="checkbox" id="agent-Qlearntab" name="agentType" value="Qlearntab" unchecked>
                                    <label for="agent-Qlearntab">Q-Learning</label>
                                </div>
                                <!-- TODO: DISABLED NEURAL AGENTS FOR NOW, UNCOMMENT WHEN READY -->
                                <!-- <div class="application-item">
                                    <input type="checkbox" id="agent-DQN" name="agentType" value="DQN">
                                    <label for="agent-DQN">Deep Q-Network</label>
                                </div>  
                                <div class="application-item">
                                    <input type="checkbox" id="agent-SB3_DQN" name="agentType" value="SB3_DQN">
                                    <label for="agent-SB3_DQN">Stable Baselines DQN</label>
                                </div>
                                <div class="application-item">
                                    <input type="checkbox" id="agent-SB3_PPO" name="agentType" value="SB3_PPO">
                                    <label for="agent-SB3_PPO">Stable Baselines PPO</label>
                                </div>
                                <div class="application-item">
                                    <input type="checkbox" id="agent-SB3_A2C" name="agentType" value="SB3_A2C">
                                    <label for="agent-SB3_A2C">Stable Baselines A2C</label>
                                </div> -->
                                <div class="application-item">
                                    <input type="checkbox" id="agent-LLM_Ollama" name="agentType" value="LLM_Ollama" unchecked>
                                    <label for="agent-LLM_Ollama">LLM Ollama Local</label>
                                </div>
                            </div>
                        </div>
                        <!-- Add new adapter selection section -->
                        <div class="config-group" style="flex: 1;">
                            <h3>Adapters</h3>
                            <div class="applications-checklist" id="adapterChecklist">
                                <!-- Adapters will be populated dynamically -->
                            </div>
                        </div>
                    </div>
                    <div class="config-row" style="display: flex; flex-wrap: wrap; gap: 20px;">
                        <div class="config-group" style="flex: 1;">
                            <h3>Training Configuration</h3>
                            <div class="training-params">
                                <label for="trainingEpisodes">Training Episodes:</label>
                                <input type="number" id="trainingEpisodes" min="10" max="10000" value="1000" step="500">
                            </div>
                            <div class="training-params">
                                <label for="trainingRepeats">Training Repeats (fixed starting position):</label>
                                <input type="number" id="trainingRepeats" min="1" max="100" value="5">
                            </div>
                            <div class="training-params">
                                <label for="trainingSeeds">Training Seeds (random starting position):</label>
                                <input type="number" id="trainingSeeds" min="1" max="100" value="1">
                            </div>
                        </div>

                        <div class="config-group" style="flex: 1;">
                            <h3>Testing Configuration</h3>
                            <div class="training-params">
                                <label for="testEpisodes">Test Episodes:</label>
                                <input type="number" id="testEpisodes" min="1" max="1000" value="200">
                            </div>
                            <div class="training-params">
                                <label for="testRepeats">Test Repeats:</label>
                                <input type="number" id="testRepeats" min="1" max="100" value="10">
                            </div>
                        </div>
                    </div>

                    {# Dynamically include agent parameter forms #}
                    {% if agent_parameter_definitions %}
                        {% for agent_id, agent_config in agent_parameter_definitions.items() %}
                            {% include 'agent_params/_generic_agent_param_form.html' %}
                        {% endfor %}
                    {% endif %}
                </div>
            </div>

            <div id="inputTab" class="tab-content" style="display:block;">
                <div align="center">   
                    <p><b>Provide language instructions to help the agent or leave blank if you want to run an experiment without</b></p>
                    <button id="resetInstructionsBtn" onclick="resetAllInstructions()" style="margin-bottom: 15px; padding: 8px 15px; background-color: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">Reset All Instructions</button>
                    <div style="margin-bottom: 15px;">
                        <input type="checkbox" id="enableLLMPlanner" name="enableLLMPlanner" unchecked>
                        <label for="enableLLMPlanner" style="color: var(--text-color); font-weight: bold; margin-left: 5px;">Enable LLM Instruction Planner</label>
                    </div>
                </div>

                <div class="input-console-container" style="display: flex; gap: 20px;">
                    <div class="input-section shadow-effect" style="flex: 1;">
                        <p>User Input</p>
                        <textarea id="userInput" placeholder="Enter your commands here..."></textarea>
                        <div class="button-group">
                            <div style="display: flex; align-items: center;">
                                <button id="submitBtn" class="submit-btn" onclick="processInput()">Submit</button>
                                <div id="loadingCircleSubmit" class="loading-circle"></div>
                            </div>
                            <button id="newInstructionBtn" onclick="newInstruction()">New Instruction</button>
                        </div>
                        <div id="rocket" class="rocket" style="display:none;">
                            🚀
                        </div>
                    </div>
                    <div class="console-section shadow-effect" style="flex: 1;">
                        <p>What the agent see to match with your input instructions</p>
                        <div id="consoleOutput"></div>
                        <div id="confirmationBlock">
                            <p>Was the result correct?</p>
                            <div style="display: flex; align-items: center;">
                                <button id="correctBtn" onclick="confirmResult(true)">Correct</button>
                                <button id="incorrectBtn" onclick="confirmResult(false)">Incorrect</button>
                                <div id="loadingCircleConfirm" class="loading-circle loading-circle-left"></div>
                            </div>
                        </div>
                        <div id="confirmationResult"></div>
                    </div>
                </div>
                <div class="image-container" style="display: flex; gap: 20px;">
                    <div id="additionalPrerenderImageContainer" class="image-section shadow-effect">
                        <div class="select-container">
                            <label for="additionalPrerenderImageSelect">Select Preview Image:</label>
                            <select id="additionalPrerenderImageSelect" class="form-select">
                                <!-- Options will be populated dynamically -->
                            </select>
                        </div>
                        <img id="additionalPrerenderImage" class="shadow-effect" style="display: none;">
                    </div>
                    <div id="instructionMatchPlots" class="image-section shadow-effect"></div>
                </div>
            </div>

            <div id="trainModelTab" class="tab-content" style="display:none;">
                <div align="center" style="padding-top: 20px;">   
                    <button id="runExperimentBtn" onclick="runExperiment()">Run Experiment</button>
                    <p style="margin-top: 15px;"><b>Click "Run Experiment" to start training the model with the current configuration and any validated instructions.</b></p>
                    <p>Ensure your application, configurations, and language inputs (if any) are set correctly in the preceding tabs.</p>
                </div>
                <div id="realTimeRenderDisplay" style="display: none;">
                    <h2>Real-time Render</h3>
                    <h3 id="realTimeRenderPhaseTitle" style="color: var(--text-color); margin-bottom: 5px;">Current Phase: N/A</h3>
                    <h4 id="realTimeRenderTitle"></h4>
                    <img id="realTimeRenderImage" src="" alt="Latest Real-time Render" />
                    <p><i>Note: The real-time render shows the fixed decision making of the most recent agent, if training is fast then this will be replaced before the animtion finishes.</i></p>
                </div>
                <div id="trainingLogOutputContainer" style="padding: 20px; display: none;"> 
                    <h2>Training Log</h3>
                    <div id="trainingLogOutput"></div>
                </div>
                
            </div>

            <div id="resultsTab" class="tab-content" style="display:none;">
                <div><h2>Instructions</h2></div>
                <div class="instructions-summary-box">
                    <div class="instructions-summary" id="instructionsSummary">
                        <!-- Instructions summary will be populated dynamically -->
                    </div>
                </div>
                <div><hr><p> </p></div>
                <div><h2>Problems Specific Results</h2></div>
                <div class="results-container" id="resultsContainer">
                    <!-- Results will be populated dynamically -->
                </div>
                <div><hr><p> </p></div>
                <div><h2>Full Variance Analysis</h2></div>
                <div class="variance-analysis-container" id="varianceAnalysisContainer">
                    <!-- Variance analysis chart will be populated dynamically -->
                </div>
            </div>
        </div>
    </div>

    <script>
        let isTraining = false;
        let cancelTraining = false;
        let allConfigs = {};
        let allObservedStates = {};
        let allPlotOptions = {};
        let allExperimentConfigs = {}; // New global variable for experiment configs
        let agentParameterDefinitions = JSON.parse('{{ agent_parameter_definitions | tojson | safe if agent_parameter_definitions else "{}" }}');

        let imagePollingInterval = null;
        let jobEventSource = null;
        let currentJobId = null;

        fetch('/get_applications')
            .then(response => response.json())
            .then(data => {
                const select = document.getElementById('applicationSelect');
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.text = 'Choose application...';
                defaultOption.disabled = true;
                defaultOption.selected = true;
                select.appendChild(defaultOption);
                data.applications.forEach(app => {
                    const option = document.createElement('option');
                    option.value = app;
                    option.textContent = app;
                    select.appendChild(option);
                });
            })
            .catch(error => console.error('Error loading applications:', error));

        fetch('/get_all_options')
            .then(response => response.json())
            .then(data => {
                allConfigs = data.localConfigs;
                allObservedStates = data.observedStates;
                allPlotOptions = data.plotOptions;
                allExperimentConfigs = data.experimentConfigs; // assign experiment configs
            })
            .catch(error => console.error('Error loading options:', error));

        document.getElementById('applicationSelect').addEventListener('change', function() {
            const selectedApp = this.value;
            const configSelections = document.getElementById('configSelections');
            const loadingOverlay = document.getElementById('loadingOverlay');
            
            if (selectedApp) {
                loadingOverlay.style.display = 'flex';
                setTimeout(() => {
                    const configSelect = document.getElementById('localConfigSelect');
                    configSelect.innerHTML = '';
                    const defaultConfigOption = document.createElement('option');
                    defaultConfigOption.value = '';
                    defaultConfigOption.text = 'Choose config...';
                    defaultConfigOption.disabled = true;
                    configSelect.appendChild(defaultConfigOption);
                    if (allConfigs[selectedApp]) {
                        allConfigs[selectedApp].forEach((config, index) => {
                            const option = document.createElement('option');
                            option.value = config;
                            option.text = config;
                            if (index === 0) {
                                option.selected = true;
                            }
                            configSelect.appendChild(option);
                        });
                    }

                    const observedStateSelect = document.getElementById('observedStateSelect');
                    observedStateSelect.innerHTML = '';
                    const defaultObservedStateOption = document.createElement('option');
                    defaultObservedStateOption.value = '';
                    defaultObservedStateOption.text = 'Select observed states data';
                    defaultObservedStateOption.disabled = true;
                    observedStateSelect.appendChild(defaultObservedStateOption);
                    if (allObservedStates[selectedApp]) {
                        allObservedStates[selectedApp].forEach((state, index) => {
                            const option = document.createElement('option');
                            option.value = state;
                            option.text = state;
                            if (index === 0) {
                                option.selected = true;
                            }
                            observedStateSelect.appendChild(option);
                        });
                    }

                    const plotSelect = document.getElementById('plotSelect');
                    plotSelect.innerHTML = '';
                    const defaultPlotOption = document.createElement('option');
                    defaultPlotOption.value = '';
                    defaultPlotOption.text = 'Choose plot...';
                    defaultPlotOption.disabled = true;
                    plotSelect.appendChild(defaultPlotOption);
                    if (allPlotOptions[selectedApp]) {
                        allPlotOptions[selectedApp].forEach((plot, index) => {
                            const option = document.createElement('option');
                            option.value = plot;
                            option.text = plot;
                            if (index === 0) {
                                option.selected = true;
                            }
                            plotSelect.appendChild(option);
                        });
                    }
                    
                    // New: Populate Experiment Config dropdown in Presets tab
                    const experimentConfigSelect = document.getElementById('experimentConfigSelect');
                    experimentConfigSelect.innerHTML = '';
                    const defaultExperimentConfigOption = document.createElement('option');
                    defaultExperimentConfigOption.value = '';
                    defaultExperimentConfigOption.text = 'Choose experiment config...';
                    defaultExperimentConfigOption.disabled = true;
                    defaultExperimentConfigOption.selected = true;
                    experimentConfigSelect.appendChild(defaultExperimentConfigOption);
                    if (allExperimentConfigs[selectedApp]) {
                        allExperimentConfigs[selectedApp].forEach((config, index) => {
                            const option = document.createElement('option');
                            option.value = config;
                            option.text = config;
                            // Remove the automatic selection of first option
                            experimentConfigSelect.appendChild(option);
                        });
                    }

                    // Add event listener for experiment config selection
                    experimentConfigSelect.addEventListener('change', function() {
                        const selectedConfig = this.value;
                        if (selectedConfig && allExperimentConfigs[selectedApp]) {
                            // Get the config data from the server
                            fetch('/get_experiment_config', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    application: selectedApp,
                                    config: selectedConfig
                                })
                            })
                            .then(response => response.json())
                            .then(data => {
                                if (data.config) {
                                    // Update agent checkboxes
                                    const agentCheckboxes = document.querySelectorAll('input[name="agentType"]');
                                    agentCheckboxes.forEach(checkbox => {
                                        checkbox.checked = data.config.agent_select.includes(checkbox.value);
                                    });

                                    // Update training parameters
                                    document.getElementById('trainingEpisodes').value = data.config.number_training_episodes || 1000;
                                    document.getElementById('trainingRepeats').value = data.config.number_training_repeats || 5;
                                    document.getElementById('trainingSeeds').value = data.config.number_training_seeds || 1;
                                    document.getElementById('testEpisodes').value = data.config.number_test_episodes || 200;
                                    document.getElementById('testRepeats').value = data.config.number_test_repeats || 10;

                                    // Dynamically update agent-specific parameters
                                    if (data.config.agent_parameters && agentParameterDefinitions) {
                                        for (const agentId in data.config.agent_parameters) {
                                            if (agentParameterDefinitions[agentId] && data.config.agent_parameters[agentId]) {
                                                const agentParamsInConfig = data.config.agent_parameters[agentId];
                                                const agentParamDefs = agentParameterDefinitions[agentId].params;
                                                for (const paramKey in agentParamDefs) {
                                                    const inputElement = document.getElementById(`${agentId}_${paramKey}`);
                                                    if (inputElement && agentParamsInConfig.hasOwnProperty(paramKey)) {
                                                        inputElement.value = agentParamsInConfig[paramKey];
                                                    } else if (inputElement) {
                                                        inputElement.value = agentParamDefs[paramKey].default;
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    // Update adapter checkboxes
                                    const adapterCheckboxes = document.querySelectorAll('input[name="adapter"]');
                                    adapterCheckboxes.forEach(checkbox => {
                                        checkbox.checked = data.config.adapter_input_dict[checkbox.value] !== undefined;
                                    });

                                    // Show/hide parameter sections based on selected agents
                                    document.querySelectorAll('input[name="agentType"]').forEach(checkbox => {
                                        const event = new Event('change');
                                        checkbox.dispatchEvent(event);
                                    });
                                }
                            })
                            .catch(error => console.error('Error loading experiment config:', error));
                        }
                    });

                    configSelections.style.display = 'block';
                    loadingOverlay.style.display = 'none';
                }, 2000); // 2-second delay

                // Fetch and display prerender images
                fetch('/get_prerender_image', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ application: selectedApp })
                })
                .then(response => response.json())
                .then(data => {
                    const prerenderImageSelect = document.getElementById('prerenderImageSelect');
                    const prerenderImage = document.getElementById('prerenderImage');
                    const additionalPrerenderImageSelect = document.getElementById('additionalPrerenderImageSelect');
                    const additionalPrerenderImage = document.getElementById('additionalPrerenderImage');
                    prerenderImageSelect.innerHTML = '';
                    prerenderImage.style.display = 'none';
                    additionalPrerenderImageSelect.innerHTML = '';
                    additionalPrerenderImage.style.display = 'none';
                    if (data.imagePaths) {
                        data.imagePaths.forEach((imagePath, index) => {
                            const option = document.createElement('option');
                            option.value = imagePath;
                            option.text = imagePath.split('/').pop();
                            if (index === 0) {
                                option.selected = true;
                                prerenderImage.src = `/${imagePath}`;
                                prerenderImage.style.display = 'block';
                                additionalPrerenderImage.src = `/${imagePath}`;
                                additionalPrerenderImage.style.display = 'block';
                            }
                            prerenderImageSelect.appendChild(option);
                            additionalPrerenderImageSelect.appendChild(option.cloneNode(true));
                        });
                    }
                })
                .catch(error => console.error('Error loading prerender images:', error));

                // Add adapter fetch
                fetch('/get_adapters', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ application: selectedApp })
                })
                .then(response => response.json())
                .then(data => {
                    const adapterChecklist = document.getElementById('adapterChecklist');
                    adapterChecklist.innerHTML = '';
                    if (data.adapters) {
                        data.adapters.forEach(adapter => {
                            const div = document.createElement('div');
                            div.className = 'application-item';
                            div.innerHTML = `
                                <input type="checkbox" id="adapter-${adapter}" name="adapter" value="${adapter}" checked>
                                <label for="adapter-${adapter}">${adapter}</label>
                            `;
                            adapterChecklist.appendChild(div);
                        });
                    }
                });
            } else {
                configSelections.style.display = 'none';
            }
        });

        document.getElementById('prerenderImageSelect').addEventListener('change', function() {
            const selectedImage = this.value;
            const prerenderImage = document.getElementById('prerenderImage');
            if (selectedImage) {
                prerenderImage.src = `/${selectedImage}`;
                prerenderImage.style.display = 'block';
            } else {
                prerenderImage.style.display = 'none';
            }
        });

        document.getElementById('additionalPrerenderImageSelect').addEventListener('change', function() {
            const selectedImage = this.value;
            const additionalPrerenderImage = document.getElementById('additionalPrerenderImage');
            if (selectedImage) {
                additionalPrerenderImage.src = `/${selectedImage}`;
                additionalPrerenderImage.style.display = 'block';
            } else {
                additionalPrerenderImage.style.display = 'none';
            }
        });

        async function processInput() {
            const input = document.getElementById('userInput');
            const submitBtn = document.getElementById('submitBtn');
            const consoleOutput = document.getElementById('consoleOutput');
            const loadingCircleSubmit = document.getElementById('loadingCircleSubmit');
            const rocket = document.getElementById('rocket');
            const instructionMatchPlots = document.getElementById('instructionMatchPlots');

            const selectedAgents = Array.from(document.querySelectorAll('input[name="agentType"]:checked'))
                .map(cb => cb.value);            

            const selectedApp = document.getElementById('applicationSelect').value;
            const localConfig = document.getElementById('localConfigSelect').value;
            const observedState = document.getElementById('observedStateSelect').value;
            const selectedPlot = document.getElementById('plotSelect').value;
            const enableLLMPlanner = document.getElementById('enableLLMPlanner').checked;

            const trainingEpisodes = document.getElementById('trainingEpisodes').value;

            if (!selectedApp) {
                alert('Please select an application');
                return;
            }

            input.disabled = true;
            submitBtn.disabled = true;
            loadingCircleSubmit.style.display = 'block';
            rocket.style.display = 'block';
            rocket.classList.add('launch');

            try {
                const response = await fetch('/process_input', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        userInput: input.value,
                        selectedApps: [selectedApp],
                        selectedAgents: selectedAgents,
                        observedStateInput: observedState,
                        localConfigInput: localConfig,
                        selectedPlot: selectedPlot,
                        trainingEpisodes: document.getElementById('trainingEpisodes').value,
                        enableLLMPlanner: enableLLMPlanner
                    })
                });

                const data = await response.json();
                loadingCircleSubmit.style.display = 'none';
                input.disabled = false;
                submitBtn.disabled = false;
                consoleOutput.innerHTML = data.console_output;
                rocket.style.display = 'none';
                rocket.classList.remove('launch');
                instructionMatchPlots.innerHTML = '';
                if (data.matchPlots && data.matchPlots.length > 0) {
                    data.matchPlots.forEach(plot => {
                        const img = document.createElement('img');
                        img.src = `/${plot}?t=${new Date().getTime()}`;
                        img.alt = 'Instruction match plot';
                        img.className = 'shadow-effect';
                        instructionMatchPlots.appendChild(img);
                    });
                }

                // Handle LLM validation if enabled
                const confirmationBlock = document.getElementById('confirmationBlock');
                if (enableLLMPlanner) {
                    // Hide manual confirmation buttons when LLM planner is enabled
                    confirmationBlock.style.display = 'none';
                    
                    // Automatically confirm result using LLM validation
                    if (data.llm_validation_result !== undefined) {
                        const confirmationResult = document.getElementById('confirmationResult');
                        if (data.llm_validation_result) {
                            confirmationResult.innerHTML = '<br>✓ LLM validation: Instructions are complete and correct.';
                            confirmationResult.style.color = 'green';
                        } else {
                            confirmationResult.innerHTML = '<br>⚠ LLM validation: Instructions may be incomplete or need refinement.';
                            confirmationResult.style.color = 'orange';
                        }
                        
                        // Automatically call confirm result with LLM validation
                        setTimeout(() => {
                            confirmResultLLM(data.llm_validation_result);
                        }, 1000);
                    }
                } else {
                    // Show manual confirmation buttons when LLM planner is disabled
                    confirmationBlock.style.display = 'block';
                }
            } catch (error) {
                console.error('Error processing input:', error);
                loadingCircleSubmit.style.display = 'none';
                input.disabled = false;
                submitBtn.disabled = false;
            }
        }

        function confirmResult(isCorrect) {
            const confirmationResult = document.getElementById('confirmationResult');
            const loadingCircleConfirm = document.getElementById('loadingCircleConfirm');
            const user_input = document.getElementById('userInput').value;
            const selectedApp = document.getElementById('applicationSelect').value;

            confirmationResult.innerHTML = '';
            loadingCircleConfirm.style.display = 'block';
            document.getElementById('loadingOverlay').style.display = 'flex';

            console.log(`Sending confirmation: isCorrect=${isCorrect}, userInput=${user_input}`);

            fetch('/confirm_result', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    isCorrect: isCorrect, 
                    userInput: user_input,
                    selectedApps: [selectedApp],
                })    
            })
            .then(response => {
                if (!response.ok) {
                    console.error('Error response from server:', response);
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                console.log('Server response:', data);
                confirmationResult.innerHTML = data.message;
                confirmationResult.style.color = isCorrect ? 'green' : 'red';
                loadingCircleConfirm.style.display = 'none';
                document.getElementById('loadingOverlay').style.display = 'none';
            })
            .catch(error => {
                console.error('Error sending confirmation:', error);
                confirmationResult.innerHTML = 'Error sending confirmation';
                confirmationResult.style.color = 'red';
                loadingCircleConfirm.style.display = 'none';
                document.getElementById('loadingOverlay').style.display = 'none';
            });
        }

        function confirmResultLLM(isCorrect) {
            const user_input = document.getElementById('userInput').value;
            const selectedApp = document.getElementById('applicationSelect').value;

            console.log(`Sending LLM confirmation: isCorrect=${isCorrect}, userInput=${user_input}`);

            fetch('/confirm_result', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    isCorrect: isCorrect, 
                    userInput: user_input,
                    selectedApps: [selectedApp],
                    isLLMValidation: true
                })    
            })
            .then(response => {
                if (!response.ok) {
                    console.error('Error response from server:', response);
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                console.log('LLM Server response:', data);
                const confirmationResult = document.getElementById('confirmationResult');
                confirmationResult.innerHTML += '<br>' + data.message;
            })
            .catch(error => {
                console.error('Error sending LLM confirmation:', error);
                const confirmationResult = document.getElementById('confirmationResult');
                confirmationResult.innerHTML += '<br>Error sending LLM confirmation';
                confirmationResult.style.color = 'red';
            });
        }

        function newInstruction() {
            document.getElementById('userInput').value = '';
            document.getElementById('consoleOutput').innerHTML = '';
            document.getElementById('instructionMatchPlots').innerHTML = '';
            document.getElementById('confirmationResult').innerHTML = '';
            fetch('/new_instruction', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ instruction: document.getElementById('userInput').value })
            })
            .then(response => response.json())
            .then(data => {
                console.log('New instruction processed:', data);
                // Clear the match plots
                document.getElementById('instructionMatchPlots').innerHTML = '';
            })
            .catch(error => console.error('Error processing new instruction:', error));
        }

        function clearPreviousJobState() {
            if (jobEventSource) {
                jobEventSource.close();
                jobEventSource = null;
            }
            if (imagePollingInterval) {
                clearInterval(imagePollingInterval);
                imagePollingInterval = null;
            }
            currentJobId = null;
            document.getElementById('realTimeRenderPhaseTitle').textContent = 'Current Phase: N/A';
            // Optionally clear log and image display areas
            // document.getElementById('trainingLogOutput').innerHTML = '';
            // document.getElementById('realTimeRenderDisplay').style.display = 'none';
        }

        async function runExperiment() {
            clearPreviousJobState(); // Clear any state from a previous run

            const selectedAgents = Array.from(document.querySelectorAll('input[name="agentType"]:checked'))
                .map(cb => cb.value);
            const selectedAdapters = Array.from(document.querySelectorAll('input[name="adapter"]:checked'))
                .map(cb => cb.value);

            const selectedApp = document.getElementById('applicationSelect').value;
            const localConfig = document.getElementById('localConfigSelect').value;
            const observedState = document.getElementById('observedStateSelect').value;
            const selectedPlot = document.getElementById('plotSelect').value;

            const trainingEpisodes = parseInt(document.getElementById('trainingEpisodes').value);
            const trainingRepeats = parseInt(document.getElementById('trainingRepeats').value);
            const trainingSeeds = parseInt(document.getElementById('trainingSeeds').value);
            const testEpisodes = parseInt(document.getElementById('testEpisodes').value);
            const testRepeats = parseInt(document.getElementById('testRepeats').value);

            if (!selectedApp) {
                alert('Please select an application');
                return;
            }
            
            // Hide previous real-time render and log, show loading overlay for the initial request
            const realTimeRenderDisplay = document.getElementById('realTimeRenderDisplay');
            realTimeRenderDisplay.style.display = 'none';
            const logContainer = document.getElementById('trainingLogOutputContainer');
            logContainer.style.display = 'block'; 
            const trainingLogOutput = document.getElementById('trainingLogOutput');
            trainingLogOutput.innerHTML = '<p>Initializing experiment...</p>'; // Initial message
            
            const loadingOverlay = document.getElementById('loadingOverlay');
            // loadingOverlay.style.display = 'flex'; // Only show for final results processing

            const params = {
                userInput: document.getElementById('userInput').value,
                trainingEpisodes: trainingEpisodes,
                trainingRepeats: trainingRepeats,
                trainingSeeds: trainingSeeds,
                testEpisodes: testEpisodes,
                testRepeats: testRepeats,
                selectedAgents: selectedAgents,
                selectedAdapters: selectedAdapters,
                selectedApps: [selectedApp],
                localConfigInput: localConfig,
                observedStateInput: observedState,
                selectedPlot: selectedPlot,
                experimentConfigSelect: document.getElementById('experimentConfigSelect').value
            };

            if (agentParameterDefinitions) {
                selectedAgents.forEach(agentId => {
                    if (agentParameterDefinitions[agentId] && agentParameterDefinitions[agentId].params) {
                        for (const paramKey in agentParameterDefinitions[agentId].params) {
                            const inputElement = document.getElementById(`${agentId}_${paramKey}`);
                            if (inputElement) {
                                params[`${agentId}_${paramKey}`] = inputElement.value;
                            }
                        }
                    }
                });
            }

            try {
                const response = await fetch('/train_model', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(params)
                });

                // loadingOverlay.style.display = 'none'; // Handled by SSE and polling logic now

                const data = await response.json(); // This is from /train_model, expecting {job_id: ...}
                if (data.error) {
                    console.error('Error starting training job:', data.error);
                    trainingLogOutput.innerHTML = `<p style="color: red;">Error starting job: ${data.error}</p>`;
                    return;
                }

                currentJobId = data.job_id;
                if (!currentJobId) {
                    trainingLogOutput.innerHTML = '<p style="color: red;">Failed to get Job ID from server.</p>';
                    return;
                }

                trainingLogOutput.innerHTML = `<p>Training job started with ID: ${currentJobId}. Waiting for updates...</p>`;
                realTimeRenderDisplay.style.display = 'block';
                document.getElementById('realTimeRenderTitle').textContent = 'Waiting for first render...';
                document.getElementById('realTimeRenderImage').src = ''; // Clear previous image

                // Start SSE for job notifications
                jobEventSource = new EventSource(`/stream_job_notifications/${currentJobId}`);

                jobEventSource.onmessage = function(event) {
                    const message = event.data;
                    console.log("SSE Message:", message);
                    if (message.startsWith("EVENT: RENDER_PHASE_TITLE:")) {
                        const phaseTitle = message.substring("EVENT: RENDER_PHASE_TITLE:".length).trim();
                        document.getElementById('realTimeRenderPhaseTitle').textContent = phaseTitle;
                        // Also log this change to the main log for visibility
                        trainingLogOutput.innerHTML += `<p style="color: mediumpurple;"><strong>Display Title Update:</strong> ${phaseTitle}</p>`;
                    } else if (message.startsWith("EVENT: JOB_COMPLETE")) {
                        trainingLogOutput.innerHTML += `<p><strong>${message}</strong></p>`;
                        if (imagePollingInterval) clearInterval(imagePollingInterval);
                        imagePollingInterval = null;
                        jobEventSource.close();
                        jobEventSource = null;
                        fetchAndDisplayFinalResults(currentJobId);
                    } else if (message.startsWith("EVENT: JOB_FAILED")) {
                        trainingLogOutput.innerHTML += `<p style="color: red;"><strong>${message}</strong></p>`;
                        if (imagePollingInterval) clearInterval(imagePollingInterval);
                        imagePollingInterval = null;
                        jobEventSource.close();
                        jobEventSource = null;
                        // Optionally try to fetch partial results or error details if your backend supports it
                    } else if (message.startsWith("ERROR:")) {
                        trainingLogOutput.innerHTML += `<p style="color: red;">${message}</p>`;
                        // Keep listening for JOB_FAILED, but log error
                    } else if (message.startsWith("WARNING:")) {
                        trainingLogOutput.innerHTML += `<p style="color: orange;">${message}</p>`;
                    } else if (message.startsWith("INFO:") || message.startsWith("EVENT:")) {
                        trainingLogOutput.innerHTML += `<p>${message}</p>`;
                    } else if (message.startsWith("SSE_ERROR:") || message.includes("Job ID") && message.includes("not found")){
                        trainingLogOutput.innerHTML += `<p style="color: red;"><strong>${message}</strong></p>`;
                        if (imagePollingInterval) clearInterval(imagePollingInterval);
                        imagePollingInterval = null;
                        jobEventSource.close(); // Critical SSE error, stop everything for this job
                        jobEventSource = null;
                    }
                    trainingLogOutput.scrollTop = trainingLogOutput.scrollHeight; // Auto-scroll
                };

                jobEventSource.onerror = function(err) {
                    trainingLogOutput.innerHTML += "<p style='color: red;'><strong>Job notification stream error. Connection lost. Polling for images will continue if active.</strong></p>";
                    console.error("Job EventSource failed:", err);
                    // Don't necessarily stop image polling here, as the job might still be running
                    // but do close this specific EventSource instance
                    if (jobEventSource) {
                        jobEventSource.close();
                        jobEventSource = null;
                    }
                };

                // Start polling for latest image
                if (imagePollingInterval) clearInterval(imagePollingInterval); // Clear previous if any
                imagePollingInterval = setInterval(async () => {
                    if (!currentJobId) { // Stop if job ID is cleared (e.g., job ended)
                        if (imagePollingInterval) clearInterval(imagePollingInterval);
                        return;
                    }
                    try {
                        const rtImageResponse = await fetch(`/get_latest_real_time_image`);
                        const rtImageData = await rtImageResponse.json();
                        if (rtImageData.image_path) {
                            const imgElement = document.getElementById('realTimeRenderImage');
                            // Only update if src is different to avoid flicker/reload of same image
                            const newSrc = `/${rtImageData.image_path}?t=${new Date().getTime()}`;
                            if (imgElement.src !== newSrc) {
                                imgElement.src = newSrc;
                            }
                            document.getElementById('realTimeRenderTitle').textContent = rtImageData.filename;
                            if(realTimeRenderDisplay.style.display === 'none') realTimeRenderDisplay.style.display = 'block';
                        } else if (rtImageData.message && document.getElementById('realTimeRenderImage').src === '') {
                            // Show message only if no image has been loaded yet
                            const filenameOnly = rtImageData.filename ? `File: ${rtImageData.filename}` : (rtImageData.message || 'Polling for image...');
                            document.getElementById('realTimeRenderTitle').textContent = filenameOnly;
                        }
                        // No need to show error from polling if SSE is active and will report job failure
                    } catch (rtError) {
                        console.warn('Error polling for latest real-time image:', rtError);
                        const currentFileTitle = document.getElementById('realTimeRenderTitle').textContent;
                        if (!currentFileTitle.includes("File:")) { // Avoid overwriting if a filename is already there
                            document.getElementById('realTimeRenderTitle').textContent = 'Error polling for image file.';
                        }
                    }
                }, 3000); // Poll every 3 seconds

            } catch (error) {
                console.error('Error initiating experiment run:', error);
                trainingLogOutput.innerHTML = `<p style="color: red;">Failed to initiate experiment: ${error}</p>`;
                if (loadingOverlay) loadingOverlay.style.display = 'none'; // Ensure overlay is off on error
            }
        }

        async function fetchAndDisplayFinalResults(jobId) {
            const loadingOverlay = document.getElementById('loadingOverlay');
            loadingOverlay.style.display = 'flex';
            const trainingLogOutput = document.getElementById('trainingLogOutput');
            trainingLogOutput.innerHTML += `<p>Fetching final results for job ${jobId}...</p>`;

            try {
                const resultsResponse = await fetch(`/get_job_results/${jobId}`);
                const jobResultsData = await resultsResponse.json();

                if (jobResultsData.error) {
                    trainingLogOutput.innerHTML += `<p style="color: red;">Error fetching final results: ${jobResultsData.error}</p>`;
                    return;
                }
                
                const data = jobResultsData.results; // Assuming results are nested under a 'results' key
                if (!data || data.status === 'failed'){
                    trainingLogOutput.innerHTML += `<p style="color: red;">Job ${jobId} failed or no results available. Error: ${data ? data.error : 'Unknown'}</p>`;
                    return;
                }

                const instructionsSummary = document.getElementById('instructionsSummary');
                const resultsContainer = document.getElementById('resultsContainer');
                const varianceAnalysisContainer = document.getElementById('varianceAnalysisContainer');
                instructionsSummary.innerHTML = '';
                resultsContainer.innerHTML = '';
                varianceAnalysisContainer.innerHTML = '';

                const correctInstructionsResponse = await fetch('/get_correct_instructions');
                const correctInstructionsData = await correctInstructionsResponse.json();
                const correctInstructions = correctInstructionsData.correctInstructions;

                correctInstructions.forEach((instruction, index) => {
                    const instructionDiv = document.createElement('div');
                    const instructions = instruction.split('\n').join(' - ');
                    instructionDiv.innerHTML = `<b>Instruction ${index}:</b> ${instructions}`;
                    instructionsSummary.appendChild(instructionDiv);
                });

                if (data.figures && data.figures.length > 0) {
                    data.figures.forEach(figPath => {
                        const img = document.createElement('img');
                        img.src = `/${figPath}?t=${new Date().getTime()}`;
                        img.alt = 'Analysis result';
                        img.className = 'shadow-effect';
                        
                        const plotContainer = document.createElement('div');
                        plotContainer.className = 'plot-container';
                        plotContainer.style.marginBottom = '20px';
                        
                        const filename = figPath.split('/').pop().split('.')[0];
                        const title = document.createElement('h3');
                        title.textContent = filename.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        title.style.marginBottom = '10px';
                        title.style.color = 'var(--text-color)';
                        
                        plotContainer.appendChild(title);
                        plotContainer.appendChild(img);

                        if (figPath.includes('variance_analysis')) {
                            varianceAnalysisContainer.appendChild(plotContainer);
                        } else {
                            resultsContainer.appendChild(plotContainer);
                        }
                    });
                } else {
                     resultsContainer.innerHTML = '<p>No figures were generated or found for this experiment.</p>';
                }

            } catch (error) {
                console.error('Error fetching final results:', error);
                trainingLogOutput.innerHTML += `<p style="color: red;">Error fetching final results: ${error}</p>`;
            } finally {
                loadingOverlay.style.display = 'none';
            }
        }

        function openTab(evt, tabName) {
            var i, tabcontent, tablinks;
            
            tabcontent = document.getElementsByClassName("tab-content");
        
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }
            tablinks = document.getElementsByClassName("tab-btn");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }
            document.getElementById(tabName).style.display = "block";
            if (evt) {
                evt.currentTarget.className += " active";
            } else {
                const defaultActiveButton = document.querySelector(`.tab-btn[onclick*="${tabName}"]`);
                if (defaultActiveButton) {
                    defaultActiveButton.className += " active";
                }            
            }
        }

        window.onload = function() {
            openTab(null, 'setupTab');
            fetch('/load_data')
                .then(response => response.json())
                .then(data => {
                    console.log('Data loaded successfully');
                })
                .catch(error => console.error('Error loading data:', error));
        };

        document.querySelectorAll('input[name="agentType"]').forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                const qlearnParams = document.getElementById('qlearn-params');
                const dqnParams = document.getElementById('dqn-params');
                const sb3DqnParams = document.getElementById('sb3-dqn-params');
                const sb3PpoParams = document.getElementById('sb3-ppo-params');
                const sb3A2cParams = document.getElementById('sb3-a2c-params');
                const LLMOllamaParams = document.getElementById('LLM-Ollama-params');
                
                // Generic handling for all agent parameter sections
                if (agentParameterDefinitions) {
                    for (const agentId in agentParameterDefinitions) {
                        const agentParamsDiv = document.getElementById(`${agentId}-params`);
                        if (agentParamsDiv) {
                            if (this.value === agentId) {
                                agentParamsDiv.style.display = this.checked ? 'block' : 'none';
                            } else if (!document.getElementById(`agent-${agentId}`).checked) {
                                // Hide other non-selected agent param divs if this one is being unchecked.
                                // This logic might need refinement if multiple agents can be selected and their params shown simultaneously.
                                // For now, it assumes one agent's params are shown at a time based on its checkbox.
                                // agentParamsDiv.style.display = 'none'; 
                            }
                        }
                    }
                }

                // Keep specific handling for old IDs if they exist for some reason (e.g. during transition)
                // or if new agents are added without using the generic template (not recommended)
                if (this.value === 'Qlearntab' && qlearnParams) {
                    qlearnParams.style.display = this.checked ? 'block' : 'none';
                } else if (this.value === 'DQN' && dqnParams) {
                    dqnParams.style.display = this.checked ? 'block' : 'none';
                } else if (this.value === 'SB3_DQN' && sb3DqnParams) {
                    sb3DqnParams.style.display = this.checked ? 'block' : 'none';
                } else if (this.value === 'SB3_PPO' && sb3PpoParams) {
                    sb3PpoParams.style.display = this.checked ? 'block' : 'none';
                } else if (this.value === 'SB3_A2C' && sb3A2cParams) {
                    sb3A2cParams.style.display = this.checked ? 'block' : 'none';
                } else if (this.value === 'LLM_Ollama' && LLMOllamaParams) {
                    LLMOllamaParams.style.display = this.checked ? 'block' : 'none';
                }
            });
        });

        async function resetAllInstructions() {
            if (!confirm("Are you sure you want to reset all instructions and their validation states? This action cannot be undone.")) {
                return;
            }
            try {
                const response = await fetch('/reset_all_instructions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                const data = await response.json();
                if (data.status === 'success') {
                    document.getElementById('userInput').value = '';
                    document.getElementById('consoleOutput').innerHTML = '';
                    document.getElementById('instructionMatchPlots').innerHTML = '';
                    document.getElementById('confirmationResult').innerHTML = '<p style="color: green;">All instructions have been reset.</p>';
                    // Call newInstruction to reset any client-side counters or states related to current input if needed
                    // This will also effectively reset global_input_count on server if new_instruction makes a call that implies it.
                    // However, /reset_all_instructions already resets global_input_count on server.
                    // For simple UI reset:
                    fetch('/new_instruction', { method: 'POST' }) // This ensures any specific UI state tied to new_instruction is also reset
                        .then(() => console.log("Client-side new instruction state also reset."))
                        .catch(err => console.error("Error calling /new_instruction during reset:", err));
                    
                    alert(data.message);
                } else {
                    alert("Failed to reset instructions: " + (data.message || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error resetting instructions:', error);
                alert('An error occurred while trying to reset instructions.');
            }
        }

    </script>
</body>
</html>