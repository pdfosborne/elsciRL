<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Demo WebApp</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <style>
        .loading-circle {
            border: 8px solid var(--border-color);
            border-top: 8px solid var(--button-color);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            display: none;
            margin-left: 10px;
        }

        .loading-circle-left {
            margin-right: 10px;
            margin-left: 0;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .training-params {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .training-params input {
            width: 100px;
            padding: 5px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }
        
        .training-params label {
            color: var(--text-color);
            font-weight: bold;
        }

        .form-select {
            width: 200px;
            padding: 5px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: white;
            color: var(--text-color);
        }

        .applications-checklist {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        .application-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .application-item input[type="checkbox"] {
            margin: 0;
        }

        .application-item label {
            color: var(--text-color);
            font-size: 14px;
        }

        .config-section {
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .config-group {
            border: 1px solid var(--border-color);
            padding: 15px;
            border-radius: 4px;
        }

        .config-group h3 {
            margin-top: 0;
            color: var(--text-color);
            font-size: 1.1em;
            margin-bottom: 15px;
        }

        .select-container {
            margin-bottom: 15px;
        }

        .select-container label {
            display: block;
            margin-bottom: 5px;
            color: var(--text-color);
            font-weight: bold;
        }

        .select-container select {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: white;
            color: var(--text-color);
        }

        .select-container select:focus {
            outline: none;
            border-color: var(--button-color);
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .checkbox-container input[type="checkbox"] {
            margin: 0;
        }

        .checkbox-container label {
            color: var(--text-color);
            font-size: 14px;
            margin: 0;
        }

        .agent-params {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .agent-adapter-group {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: #f9f9f9;
        }

        .agent-adapter-group h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: var(--text-color);
            font-size: 1em;
        }

        .adapter-checkboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        /* Interface Guide Styles */
        #interfaceGuideContent {
            max-height: 70vh;
            overflow-y: auto;
            padding-right: 5px;
        }

        #interfaceGuideContent h1,
        #interfaceGuideContent h2,
        #interfaceGuideContent h3,
        #interfaceGuideContent h4 {
            color: var(--text-color);
            margin-top: 15px;
            margin-bottom: 10px;
        }

        #interfaceGuideContent h1 {
            font-size: 1.4em;
            border-bottom: 2px solid var(--button-color);
            padding-bottom: 5px;
        }

        #interfaceGuideContent h2 {
            font-size: 1.2em;
            color: var(--button-color);
        }

        #interfaceGuideContent h3 {
            font-size: 1.1em;
        }

        #interfaceGuideContent p {
            margin-bottom: 10px;
            line-height: 1.4;
        }

        #interfaceGuideContent ul,
        #interfaceGuideContent ol {
            margin-bottom: 10px;
            padding-left: 20px;
        }

        #interfaceGuideContent li {
            margin-bottom: 5px;
            line-height: 1.3;
        }

        #interfaceGuideContent code {
            background-color: #f4f4f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        #interfaceGuideContent pre {
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 10px 0;
        }

        #interfaceGuideContent blockquote {
            border-left: 4px solid var(--button-color);
            margin: 10px 0;
            padding-left: 15px;
            color: #666;
        }

        .loading-message {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .error-message {
            padding: 10px;
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
            color: #856404;
        }

        /* Application Overview Styles */
        .applications-overview {
            padding: 10px 0;
        }

        .applications-overview h3 {
            color: var(--button-color);
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--border-color);
        }

        .app-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .app-card {
            background-color: var(--input-background-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px var(--shadow-color);
            transition: all 0.3s ease;
        }

        .app-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow-color);
        }

        .app-card h4 {
            margin: 0 0 10px 0;
            color: var(--button-color);
            font-size: 1.1em;
        }

        .app-details {
            font-size: 0.9em;
            line-height: 1.4;
        }

        .app-details p {
            margin: 5px 0;
            color: var(--text-color);
        }

        /* Configuration Selection Styles */
        .config-selection {
            margin-top: 20px;
            padding: 15px;
            background-color: var(--input-background-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
        }

        .config-selection h5 {
            margin: 0 0 15px 0;
            color: var(--button-color);
            font-size: 1.1em;
        }

        .config-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        .config-button {
            background-color: var(--button-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.3s ease;
        }

        .config-button:hover {
            background-color: var(--button-hover-color);
        }

        .config-button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .config-dropdown {
            display: none;
            margin-top: 10px;
            padding: 10px;
            background-color: var(--background-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        .config-dropdown.show {
            display: block;
        }

        .config-dropdown select {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: white;
            color: var(--text-color);
            font-size: 0.9em;
        }

        .config-dropdown label {
            display: block;
            margin-bottom: 5px;
            color: var(--text-color);
            font-weight: bold;
            font-size: 0.9em;
        }

        .config-dropdown p {
            margin: 5px 0;
            color: var(--text-color);
            font-size: 0.9em;
        }

        .config-actions {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }

        .config-actions button {
            padding: 6px 12px;
            font-size: 0.8em;
        }

        .config-actions .apply-btn {
            background-color: var(--button-color);
            color: white;
        }

        .config-actions .cancel-btn {
            background-color: #6c757d;
            color: white;
        }

        /* Button-based Configuration Selection Styles */
        .config-option-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 10px;
        }

        .config-option-button {
            background-color: var(--input-background-color);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
            position: relative;
        }

        .config-option-button:hover {
            border-color: var(--button-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow-color);
        }

        .config-option-button.selected {
            border-color: var(--button-color);
            background-color: rgba(0, 123, 255, 0.1);
        }

        .config-option-button.selected::after {
            content: "✓";
            position: absolute;
            top: 10px;
            right: 10px;
            color: var(--button-color);
            font-weight: bold;
            font-size: 1.2em;
        }

        .config-option-title {
            font-weight: bold;
            color: var(--text-color);
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        .config-option-description {
            color: var(--text-color);
            font-size: 0.9em;
            line-height: 1.4;
            margin-bottom: 5px;
        }

        .config-option-meta {
            color: #666;
            font-size: 0.8em;
            font-style: italic;
        }

        /* Overview Configuration Styles */
        .config-option-btn {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: white;
            color: var(--text-color);
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            margin: 2px;
        }

        .config-option-btn:hover {
            border-color: var(--button-color);
            background-color: #f8f9fa;
        }

        .config-option-btn.selected {
            background-color: var(--button-color);
            border-color: var(--button-color);
            color: white;
        }

        .config-selection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .config-selection-card {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            background-color: var(--input-background-color);
        }

        .config-selection-card h4 {
            margin: 0 0 15px 0;
            color: var(--button-color);
        }

        .config-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .config-section-title {
            color: var(--button-color);
            margin: 0;
            font-size: 1.2em;
        }

        .config-clear-btn {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8em;
            cursor: pointer;
        }

        .config-clear-btn:hover {
            background-color: #c82333;
        }

        .no-options-message {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 20px;
            background-color: var(--input-background-color);
            border-radius: 4px;
            margin-top: 10px;
        }

        .download-btn {
            background-color: var(--button-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
            transition: background-color 0.3s ease;
        }

        .download-btn:hover {
            background-color: var(--button-hover-color);
        }

        /* Selected Application Details Styles */
        #selectedApplicationDetails {
            margin-top: 30px;
            padding: 20px;
            background-color: var(--input-background-color);
            border: 2px solid var(--button-color);
            border-radius: 8px;
            box-shadow: 0 4px 8px var(--shadow-color);
        }

        #selectedApplicationDetails h3 {
            color: var(--button-color);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border-color);
        }

        #selectedApplicationDetails h4 {
            color: var(--text-color);
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        #selectedApplicationDetails h5 {
            color: var(--button-color);
            margin: 20px 0 10px 0;
            font-size: 1.1em;
        }

        .prerender-image-section {
            margin-bottom: 20px;
        }

        .prerender-image {
            max-width: 100%;
            max-height: 400px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-shadow: 0 2px 4px var(--shadow-color);
            margin: 10px 0;
        }

        .readme-section {
            margin-bottom: 20px;
        }

        .readme-content {
            background-color: #f8f9fa;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 15px;
            max-height: 500px;
            overflow-y: auto;
        }

        .readme-content h1,
        .readme-content h2,
        .readme-content h3,
        .readme-content h4,
        .readme-content h5,
        .readme-content h6 {
            color: var(--button-color);
            margin: 15px 0 10px 0;
            font-weight: bold;
        }

        .readme-content h1 {
            font-size: 1.4em;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 5px;
        }

        .readme-content h2 {
            font-size: 1.2em;
        }

        .readme-content h3 {
            font-size: 1.1em;
        }

        .readme-content p {
            margin: 10px 0;
            line-height: 1.5;
        }

        .readme-content code {
            background-color: #e9ecef;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .readme-content pre {
            background-color: #e9ecef;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            overflow-x: auto;
        }

        .readme-content pre code {
            background-color: transparent;
            padding: 0;
        }

        .readme-content a {
            color: var(--button-color);
            text-decoration: none;
        }

        .readme-content a:hover {
            text-decoration: underline;
        }

        .readme-content strong {
            font-weight: bold;
        }

        .readme-content em {
            font-style: italic;
        }

        /* Results Tab Styles */
        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border-color);
        }

        .results-header h3 {
            color: var(--button-color);
            margin: 0;
        }

        .refresh-results-btn {
            background-color: var(--button-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s ease;
        }

        .refresh-results-btn:hover {
            background-color: var(--button-hover-color);
        }

        .variance-results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .variance-result-card {
            background-color: var(--input-background-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px var(--shadow-color);
            transition: all 0.3s ease;
        }

        .variance-result-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow-color);
        }

        .variance-result-card h4 {
            color: var(--button-color);
            margin: 0 0 10px 0;
            font-size: 1.1em;
        }

        .variance-result-card img {
            max-width: 100%;
            height: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            margin: 10px 0;
        }

        .variance-result-info {
            font-size: 0.9em;
            color: var(--text-color);
            margin: 5px 0;
        }

        .no-results-message {
            text-align: center;
            padding: 40px 20px;
            color: #666;
            font-style: italic;
        }

        /* Make app cards clickable */
        .app-card {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .app-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow-color);
            border-color: var(--button-color);
        }

        .app-card.selected {
            border-color: var(--button-color);
            background-color: rgba(0, 122, 255, 0.1);
            box-shadow: 0 4px 8px var(--shadow-color);
        }

        .app-card.selected h4 {
            color: var(--button-color);
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            color: var(--text-color);
            font-weight: bold;
        }

        .input-group input, .input-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: white;
            color: var(--text-color);
        }

        .input-group input:focus, .input-group textarea:focus {
            outline: none;
            border-color: var(--button-color);
        }

        .input-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .button-group button {
            flex: 1;
        }

        /* New Layout Styles */
        .main-layout {
            display: flex;
            min-height: 100vh;
            background-color: var(--background-color);
        }

        .left-sidebar {
            width: 300px;
            background-color: var(--box-color);
            border-right: 1px solid var(--border-color);
            padding: 20px;
            overflow-y: auto;
            max-height: 100vh;
        }

        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            max-height: 100vh;
        }

        .right-sidebar {
            width: 250px;
            background-color: var(--box-color);
            border-left: 1px solid var(--border-color);
            padding: 20px;
            overflow-y: auto;
            max-height: 100vh;
        }

        .sidebar-block {
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
        }

        .sidebar-block-header {
            background-color: var(--button-color);
            color: white;
            padding: 12px 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }

        .sidebar-block-header:hover {
            background-color: var(--button-hover-color);
        }

        .sidebar-block-content {
            padding: 15px;
            display: none;
            background-color: white;
        }

        .sidebar-block-content.active {
            display: block;
        }

        .sidebar-block-header .toggle-icon {
            transition: transform 0.3s ease;
        }

        .sidebar-block-header.active .toggle-icon {
            transform: rotate(180deg);
        }

        /* Tab Navigation Styles */
        .tab-navigation {
            display: flex;
            border-bottom: 2px solid var(--border-color);
            margin-bottom: 20px;
            background-color: var(--box-color);
            border-radius: 8px 8px 0 0;
            padding: 0;
        }

        .tab-btn {
            background-color: transparent;
            border: none;
            padding: 15px 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: var(--text-color);
            font-size: 16px;
            font-weight: 500;
            border-radius: 8px 8px 0 0;
            margin-right: 2px;
        }

        .tab-btn:hover {
            background-color: var(--input-background-color);
            color: var(--button-color);
        }

        .tab-btn.active {
            background-color: var(--button-color);
            color: white;
            border-bottom: 2px solid var(--button-color);
        }

        .tab-content {
            display: none;
            background-color: var(--box-color);
            border-radius: 0 0 8px 8px;
            padding: 0;
            margin-bottom: 20px;
        }

        .tab-content.active {
            display: block;
        }

        .tab-content-inner {
            padding: 20px;
        }

        .main-content-section {
            display: none;
            background-color: var(--box-color);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .main-content-section.active {
            display: block;
        }

        .right-sidebar-section {
            background-color: var(--box-color);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .logo-section {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .logo-section img {
            width: 200px;
            height: 200px;
        }

        @media (max-width: 1024px) {
            .main-layout {
                flex-direction: column;
            }
            
            .left-sidebar, .right-sidebar {
                width: 100%;
                max-height: none;
            }
            
            .left-sidebar {
                order: 1;
            }
            
            .main-content {
                order: 2;
            }
            
            .right-sidebar {
                order: 3;
            }
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
                                <div class="loading-circle"></div>
                            </div>
    
    <div class="main-layout">
        <!-- Left Sidebar -->
        <div class="left-sidebar">
            <div class="logo-section">
                <a href="https://elsci.org">
                    <img src="https://raw.githubusercontent.com/pdfosborne/elsciRL-Wiki/refs/heads/main/Resources/images/elsciRL_octlogo_black_outline_transparent.png" alt="elsciRL-Logo">
                </a>
                        </div>

            <!-- Home Block -->
            <div class="sidebar-block">
                <div class="sidebar-block-header" onclick="toggleBlock(this)">
                    <span>Help</span>
                    <span class="toggle-icon">▼</span>
                    </div>
                <div class="sidebar-block-content">
                    <div id="interfaceGuideContent">
                        <div class="loading-message">
                            <p>Loading interface guide...</p>
                </div>
            </div>
                            </div>
                        </div>

            <!-- Applications Block -->
            <div class="sidebar-block">
                <div class="sidebar-block-header active" onclick="toggleBlock(this)">
                    <span>Applications</span>
                    <span class="toggle-icon">▼</span>
                        </div>
                <div class="sidebar-block-content active">
                    <div class="config-group">
                        <h3>Available Applications</h3>
                        <div class="button-group" style="margin-bottom: 15px;">
                            <button onclick="checkAllUpdates()">Check Updates</button>
                </div>
                        <div id="updateStatus" style="margin-bottom: 15px; display: none;"></div>
                        <div id="applicationsList">
                            <p>Loading applications...</p>
                        </div>
                    </div>
                    
                    <div class="config-group">
                        <h3>Download Applications</h3>
                        <div id="downloadableApps">
                            <p>Loading available applications...</p>
                </div>
            </div>
                                </div>
                                </div>
                    
            <!-- Experiment Block -->
            <div class="sidebar-block">
                <div class="sidebar-block-header" onclick="toggleBlock(this)">
                    <span>Experiment</span>
                    <span class="toggle-icon">▼</span>
                            </div>
                <div class="sidebar-block-content">
                    <div class="config-group">
                        <h3>Application Selection</h3>
                            <div class="select-container">
                            <label for="applicationSelect">Select Application:</label>
                            <select id="applicationSelect" onchange="loadApplicationData()">
                                <option value="">Loading applications...</option>
                                    </select>
                                </div>
                        <div id="applicationInfo" style="margin-top: 10px; padding: 10px; background-color: #f5f5f5; border-radius: 4px; display: none;">
                            <p><strong>Status:</strong> <span id="appStatus"></span></p>
                            <p><strong>Last Updated:</strong> <span id="appLastUpdated"></span></p>
                            <p><strong>Components:</strong> <span id="appComponents"></span></p>
                                </div>
                            </div>

                    <div class="config-group">
                        <h3>Configuration</h3>
                        
                        <!-- Local Config Selection -->
                        <div class="select-container">
                            <label for="localConfigSelect">Local Configuration:</label>
                            <select id="localConfigSelect" onchange="updateConfigSummary()">
                                <option value="">Select application first</option>
                            </select>
                        </div>
                        
                        <!-- Observed States Selection -->
                        <div class="select-container">
                            <label for="observedStateSelect">Observed States:</label>
                            <select id="observedStateSelect" onchange="updateConfigSummary()">
                                <option value="">Select application first</option>
                            </select>
                        </div>
                        
                        <!-- Analysis Plot Selection -->
                        <div class="select-container">
                            <label for="plotSelect">Analysis Plot:</label>
                            <select id="plotSelect" onchange="updateConfigSummary()">
                                <option value="">Select application first</option>
                            </select>
                        </div>
                    </div>

                    <div class="config-group">
                        <h3>Training Parameters</h3>
                            <div class="training-params">
                            <label for="trainingEpisodes">Episodes:</label>
                            <input type="number" id="trainingEpisodes" value="1000" min="1">
                            </div>
                            <div class="training-params">
                            <label for="trainingRepeats">Repeats:</label>
                            <input type="number" id="trainingRepeats" value="5" min="1">
                            </div>
                            <div class="training-params">
                            <label for="testEpisodes">Test Episodes:</label>
                            <input type="number" id="testEpisodes" value="200" min="1">
                            </div>
                            <div class="training-params">
                            <label for="testRepeats">Test Repeats:</label>
                            <input type="number" id="testRepeats" value="10" min="1">
                        </div>
                    </div>

                    <div class="config-group">
                        <h3>Configuration Management</h3>
                        <div class="button-group">
                            <button onclick="exportConfig()">Export Config</button>
                            <button onclick="document.getElementById('importConfigFile').click()">Import Config</button>
                            <input type="file" id="importConfigFile" accept=".json" style="display: none;" onchange="importConfig(this)">
                                    </div>
                                </div>
                                    </div>
                                </div>  

            <!-- Config Block -->
            <div class="sidebar-block">
                <div class="sidebar-block-header" onclick="toggleBlock(this)">
                    <span>Agent Config</span>
                    <span class="toggle-icon">▼</span>
                                    </div>
                <div class="sidebar-block-content">
                    <div class="config-group">
                        <h3>Agent Selection</h3>
                        <div id="agentSelection">
                            <div class="checkbox-container">
                                <input type="checkbox" id="agent_Qlearntab" value="Qlearntab" checked onchange="updateAgentConfig()">
                                <label for="agent_Qlearntab">Q-Learning</label>
                                </div>
                            <div class="checkbox-container">
                                <input type="checkbox" id="agent_DQN" value="DQN" onchange="updateAgentConfig()">
                                <label for="agent_DQN">Deep Q-Network</label>
                                    </div>
                            <div class="checkbox-container">
                                <input type="checkbox" id="agent_LLM_Ollama" value="LLM_Ollama" onchange="updateAgentConfig()">
                                <label for="agent_LLM_Ollama">LLM Ollama</label>
                                </div>
                                    </div>
                                    </div>

                    <div class="config-group">
                        <h3>Adapter Selection</h3>
                        <div id="adapterSelection">
                            <p>Select an application and at least one agent to see available adapters.</p>
                            </div>
                        </div>

                    <div id="agentConfigContainer">
                        <!-- Agent configuration forms will be dynamically loaded here -->
                            </div>
                        </div>
                        </div>
                    </div>

        <!-- Main Content Area -->
        <div class="main-content">
            <!-- Tab Navigation -->
            <div class="tab-navigation">
                <button class="tab-btn active" onclick="switchTab('applicationOverview', this)">Application Overview</button>
                <button class="tab-btn" onclick="switchTab('instructions', this)">Instructions</button>
                <button class="tab-btn" onclick="switchTab('results', this)">Results</button>
            </div>

            <!-- Application Overview Tab -->
            <div id="applicationOverview" class="tab-content active">
                <div class="tab-content-inner">
                    <h2>Application Overview</h2>
                    <div id="applicationOverviewContent">
                        <div class="loading-message">
                            <p>Loading application overview...</p>
                </div>
            </div>
                        </div>
                    </div>

            <!-- Instructions Tab -->
            <div id="instructions" class="tab-content">
                <div class="tab-content-inner">
                    <h2>Instructions</h2>
                    <div class="input-console-container">
                        <div class="input-section">
                            <!-- Observed States Selection -->
                            <div class="config-group" style="margin-bottom: 20px;">
                                <h3>Observed States</h3>
                                <div class="select-container">
                                    <label for="instructionsObservedStateSelect">Select Observed States:</label>
                                    <select id="instructionsObservedStateSelect" onchange="updateInstructionsObservedStates()">
                                        <option value="">Select an application first</option>
                                    </select>
                                </div>
                                <div id="instructionsObservedStatesInfo" style="margin-top: 10px; padding: 10px; background-color: #f5f5f5; border-radius: 4px; display: none;">
                                    <p><strong>Selected States:</strong> <span id="instructionsObservedStatesSummary">None</span></p>
                                    <div id="instructionsObservedStatesPreview" style="margin-top: 10px; display: none;">
                                        <div style="color: #666; font-size: 0.9em; margin-bottom: 8px;">Preview of first value:</div>
                                        <pre id="instructionsObservedStatesContent" style="background-color: #f8f9fa; border: 1px solid #e9ecef; border-radius: 4px; padding: 12px; font-size: 0.85em; color: #333; overflow-x: auto; max-height: 200px; overflow-y: auto; white-space: pre-wrap; word-wrap: break-word;"></pre>
                                    </div>
                                </div>
                            </div>
                            
                            <h3>Enter Your Instructions</h3>
                            <textarea id="userInput" placeholder="Enter your task instructions here..."></textarea>
                            <div class="button-group">
                                <button id="submitBtn" onclick="processInput()">Process Instructions</button>
                                <button id="retryBtn" onclick="newInstruction()" style="display: none;">New Instruction</button>
                    </div>
                            
                            <!-- LLM Settings -->
                            <div class="config-group" style="margin-top: 20px;">
                                <h3>LLM Settings</h3>
                                <div class="checkbox-container">
                                    <input type="checkbox" id="enableLLMPlanner">
                                    <label for="enableLLMPlanner">Enable LLM Instruction Planner</label>
                        </div>
                                <div class="input-group">
                                    <label for="llmModelSelect">LLM Model:</label>
                                    <select id="llmModelSelect">
                                        <option value="llama3.2">llama3.2</option>
                                        <option value="qwen3:0.6b">qwen3:0.6b</option>
                                    </select>
                    </div>
                                <div class="input-group">
                                    <label for="llmContextLength">Context Length:</label>
                                    <input type="number" id="llmContextLength" value="1000" min="100" max="4000">
                </div>
                                <div class="input-group">
                                    <label for="llmNumInstructions">Number of Instructions:</label>
                                    <input type="number" id="llmNumInstructions" value="1" min="1" max="10">
                        </div>
                            </div>
                        </div>
                        
                        <div class="console-section">
                            <h3>Results</h3>
                        <div id="consoleOutput"></div>
                            <div id="confirmationBlock" style="display: none;">
                            <p>Was the result correct?</p>
                                <div class="button-group">
                                <button id="correctBtn" onclick="confirmResult(true)">Correct</button>
                                <button id="incorrectBtn" onclick="confirmResult(false)">Incorrect</button>
                        </div>
                        <div id="confirmationResult"></div>
                    </div>
                </div>
                        
                        <div class="image-section">
                            <h3>Instruction Match Plots</h3>
                            <div id="instructionMatchPlots"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Results Tab -->
            <div id="results" class="tab-content">
                <div class="tab-content-inner">
                    <h2>Results</h2>
                    <div id="resultsContent">
                        <div class="results-header">
                            <h3>Variance Analysis Results</h3>
                            <button onclick="loadVarianceResults()" class="refresh-results-btn">Refresh Results</button>
                        </div>
                        <div id="varianceResults">
                            <p>Click "Refresh Results" to load variance analysis results from the uploads directory.</p>
                    </div>
                        </div>
                    </div>
                </div>
                    </div>

        <!-- Right Sidebar -->
        <div class="right-sidebar">
            <div class="right-sidebar-section">
                <h3>Train Model</h3>
                <p>Start training with or without instructions. Select agents and click to begin.</p>
                <button id="trainModelBtn" onclick="startTraining()" style="width: 100%; padding: 15px; font-size: 16px; font-weight: bold;">
                    Train Model
                </button>
                <div id="trainingStatus" style="margin-top: 15px; display: none;">
                    <div class="loading-circle-left"></div>
                    <span>Training in progress...</span>
                </div>   
            </div>

            <div class="right-sidebar-section">
                <h3>Preset Instructions</h3>
                <p>Load preset instruction plans for the selected application.</p>
                <div class="input-group" style="margin-bottom: 10px;">
                    <label for="presetSelect" style="font-size: 12px; margin-bottom: 5px;">Select preset:</label>
                    <select id="presetSelect" onchange="onPresetSelectChange()" style="width: 100%; padding: 8px; font-size: 12px;">
                        <option value="">Choose a preset...</option>
                    </select>
                </div>
                <div id="presetDescription" style="margin-bottom: 10px; font-style: italic; color: #666; font-size: 11px;"></div>
                <div class="button-group" style="display: flex; gap: 5px;">
                    <button onclick="loadSelectedPreset()" id="loadPresetBtn" disabled style="flex: 1; padding: 8px; font-size: 12px;">Load</button>
                    <button onclick="clearPreset()" id="clearPresetBtn" style="display: none; flex: 1; padding: 8px; font-size: 12px;">Clear</button>
                </div>
            </div>

            <div class="right-sidebar-section">
                <h3>Status</h3>
                <div id="statusInfo">
                    <p><strong>Instructions:</strong> <span id="instructionCount">0</span></p>
                    <p><strong>Applications:</strong> <span id="appCount">0</span></p>
                    <p><strong>Last Update:</strong> <span id="lastUpdate">Never</span></p>
                    </div>
                </div>
        </div>
    </div>

    <script>
        // Global variables
        let instructionPresetActive = false;
        let currentJobId = null;
        let agentDefinitions = {};
        let availableAdapters = [];

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            loadApplications();
            loadAllApplicationsInfo();
            loadAllOptions();
            loadAgentDefinitions();
            updateAdapterSelection(); // Initialize adapter selection with first option selected
            loadInterfaceGuide(); // Load the interface guide
            loadApplicationOverview(); // Load the application overview
            updateStatus();
        });

        // Toggle sidebar blocks
        function toggleBlock(header) {
            const content = header.nextElementSibling;
            const isActive = content.classList.contains('active');
            
            // Close all other blocks
            document.querySelectorAll('.sidebar-block-content').forEach(block => {
                block.classList.remove('active');
            });
            document.querySelectorAll('.sidebar-block-header').forEach(h => {
                h.classList.remove('active');
            });
            
            // Toggle current block
            if (!isActive) {
                content.classList.add('active');
                header.classList.add('active');
            }
        }

        // Switch tabs
        function switchTab(tabId, eventElement = null) {
            // Remove active class from all tabs and tab buttons
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Add active class to selected tab and button
            document.getElementById(tabId).classList.add('active');
            if (eventElement) {
                eventElement.classList.add('active');
            } else {
                // Find the corresponding tab button and activate it
                const tabButtons = document.querySelectorAll('.tab-btn');
                tabButtons.forEach(btn => {
                    if (btn.getAttribute('onclick') && btn.getAttribute('onclick').includes(tabId)) {
                        btn.classList.add('active');
                    }
                });
            }
        }

        // Toggle main content sections (legacy function - keeping for compatibility)
        function toggleMainSection(sectionId) {
            document.querySelectorAll('.main-content-section').forEach(section => {
                section.classList.remove('active');
            });
            document.getElementById(sectionId).classList.add('active');
        }

        // Load applications
        async function loadApplications() {
            try {
                const response = await fetch('/get_applications');
                const data = await response.json();
                
                const select = document.getElementById('applicationSelect');
                select.innerHTML = '<option value="">Select an application...</option>';
                    
                    data.applications.forEach(app => {
                        const option = document.createElement('option');
                        option.value = app;
                        option.textContent = app;
                        select.appendChild(option);
                    });
                    
                document.getElementById('appCount').textContent = data.applications.length;
            } catch (error) {
                console.error('Error loading applications:', error);
            }
        }

        // Load all applications info for management
        async function loadAllApplicationsInfo() {
            try {
                const response = await fetch('/get_all_applications_info');
                const data = await response.json();
                
                // Update downloaded applications list
                const applicationsList = document.getElementById('applicationsList');
                applicationsList.innerHTML = '';
                
                if (data.applications && data.applications.length > 0) {
                    data.applications.forEach(app => {
                        if (app.is_downloaded) {
                            const appDiv = document.createElement('div');
                            appDiv.className = 'application-item';
                            // Create GitHub link if repository info is available
                            const githubLink = app.github_user && app.repository ? 
                                `<a href="https://github.com/${app.github_user}/${app.repository}" target="_blank" style="color: #0366d6; text-decoration: none; font-size: 12px; margin-left: 8px;">🔗 GitHub</a>` : '';
                            
                            appDiv.innerHTML = `
                                <div style="flex: 1;">
                                    <strong>${app.name}</strong>
                                    <div style="font-size: 12px; color: #666;">
                                        ${app.has_updates ? '🔄 Updates available' : '✅ Up to date'}
                                        ${app.last_updated ? ` • Last updated: ${formatTimestamp(app.last_updated)}` : ''}
                                        ${githubLink}
                                    </div>
                                </div>
                                ${app.has_updates ? `<button onclick="downloadApplication('${app.name}', true)" style="padding: 4px 8px; font-size: 12px;">Update</button>` : ''}
                            `;
                            applicationsList.appendChild(appDiv);
                        }
                    });
                } else {
                    applicationsList.innerHTML = '<p>No applications downloaded yet.</p>';
                }

                // Update downloadable applications list
                const downloadableApps = document.getElementById('downloadableApps');
                downloadableApps.innerHTML = '';
                
                if (data.applications && data.applications.length > 0) {
                    data.applications.forEach(app => {
                        if (!app.is_downloaded) {
                            const appDiv = document.createElement('div');
                            appDiv.className = 'application-item';
                            
                            // Create GitHub link if repository info is available
                            const githubLink = app.github_user && app.repository ? 
                                `<a href="https://github.com/${app.github_user}/${app.repository}" target="_blank" style="color: #0366d6; text-decoration: none; font-size: 12px; margin-left: 8px;">🔗 GitHub</a>` : '';
                            
                            appDiv.innerHTML = `
                                <div style="flex: 1;">
                                    <strong>${app.name}</strong>
                                    <div style="font-size: 12px; color: #666;">
                                        ${app.adapters_count} adapters • ${app.configs_count} configs • ${app.experiment_configs_count} experiments
                                        ${githubLink}
                                    </div>
                                </div>
                                <button onclick="downloadApplication('${app.name}', false)" style="padding: 4px 8px; font-size: 12px;">
                                    Download
                                </button>
                            `;
                            downloadableApps.appendChild(appDiv);
                        }
                    });
                } else {
                    downloadableApps.innerHTML = '<p>No applications available for download.</p>';
                }

            } catch (error) {
                console.error('Error loading all applications info:', error);
                document.getElementById('applicationsList').innerHTML = '<p>Error loading applications.</p>';
                document.getElementById('downloadableApps').innerHTML = '<p>Error loading applications.</p>';
            }
        }

        // Download application
        async function downloadApplication(appName, forceUpdate = false) {
            try {
                const response = await fetch('/download_application', {
                                method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                        application_name: appName, 
                        force_update: forceUpdate 
                    })
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    alert(`Successfully ${forceUpdate ? 'updated' : 'downloaded'} ${appName}!`);
                    loadAllApplicationsInfo(); // Refresh the lists
                    loadApplications(); // Refresh the dropdown
                } else if (data.status === 'needs_confirmation') {
                    if (confirm(`${data.message}\n\nDo you want to proceed with the update?`)) {
                        // User confirmed, try again with force update
                        downloadApplication(appName, true);
                    }
                } else {
                    alert(`Error: ${data.message}`);
                }
            } catch (error) {
                console.error('Error downloading application:', error);
                alert('An error occurred while downloading the application.');
            }
        }

        // Load application data
        async function loadApplicationData() {
            const selectedApp = document.getElementById('applicationSelect').value;
            if (!selectedApp) return;

            try {
                // Load configs, observed states, plots, and adapters
                const [configsRes, statesRes, plotsRes, adaptersRes] = await Promise.all([
                    fetch('/get_local_configs', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ application: selectedApp })
                    }),
                    fetch('/get_observed_states', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ applications: [selectedApp] })
                    }),
                    fetch('/get_plot_options', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ application: selectedApp })
                    }),
                    fetch('/get_adapters', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ application: selectedApp })
                    })
                ]);

                const [configsData, statesData, plotsData, adaptersData] = await Promise.all([
                    configsRes.json(),
                    statesRes.json(),
                    plotsRes.json(),
                    adaptersRes.json()
                ]);

                // Load configuration options as dropdowns
                loadConfigurationDropdowns(selectedApp, configsData, statesData, plotsData);
                
                // Load observed states for instructions tab
                loadInstructionsObservedStates(selectedApp, statesData);
                
                // Update adapters
                availableAdapters = adaptersData.adapters || [];
                updateAdapterSelection();

                // Update selection in application overview
                updateApplicationOverviewSelection(selectedApp);

                // Load preset instructions for this application
                loadPresetInstructions();

            } catch (error) {
                console.error('Error loading application data:', error);
            }
        }

        // Update application overview selection to match dropdown selection
        function updateApplicationOverviewSelection(selectedApp) {
            // Remove previous selection
            document.querySelectorAll('.app-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            // Find and select the corresponding card
            const appCards = document.querySelectorAll('.app-card');
            appCards.forEach(card => {
                const appName = card.querySelector('h4').textContent;
                if (appName === selectedApp) {
                    card.classList.add('selected');
                }
            });
            
            // Show configuration section and load options
            const configSection = document.getElementById('applicationConfigSection');
            if (configSection) {
                configSection.style.display = 'block';
                loadOverviewConfigurationOptions(selectedApp);
            }
        }

        // Update select dropdown
        function updateSelect(selectId, options) {
            const select = document.getElementById(selectId);
            select.innerHTML = '<option value="">Select an option...</option>';
            options.forEach(option => {
                const optionElement = document.createElement('option');
                optionElement.value = option;
                optionElement.textContent = option;
                select.appendChild(optionElement);
            });
            
            // Auto-select the first option if options are available
            if (options.length > 0) {
                select.selectedIndex = 1; // Index 1 because index 0 is the placeholder
                
                // Trigger change event for dropdowns that have onchange handlers
                if (selectId === 'localConfigSelect') {
                    loadConfigData();
                }
            }
        }

        // Load all options
        async function loadAllOptions() {
            try {
                const response = await fetch('/get_all_options');
                const data = await response.json();
                console.log('All options loaded:', data);
            } catch (error) {
                console.error('Error loading all options:', error);
            }
        }

        // Process input
        async function processInput() {
            const userInput = document.getElementById('userInput').value;
            if (!userInput.trim()) {
                alert('Please enter some instructions.');
                return;
            }

            const selectedApp = document.getElementById('applicationSelect').value;
            if (!selectedApp) {
                alert('Please select an application first.');
                return;
            }

            const submitBtn = document.getElementById('submitBtn');
            const retryBtn = document.getElementById('retryBtn');
            
            submitBtn.disabled = true;
            submitBtn.innerHTML = 'Processing... <div class="loading-circle"></div>';

            try {
                const formData = {
                    userInput: userInput,
                    selectedApps: [selectedApp],
                    localConfigInput: document.getElementById('localConfigSelect').value,
                    observedStateInput: document.getElementById('observedStateSelect').value,
                    enableLLMPlanner: document.getElementById('enableLLMPlanner').checked,
                    llmModelSelect: document.getElementById('llmModelSelect').value,
                    LLMContextLength: document.getElementById('llmContextLength').value,
                    llmNumInstructions: document.getElementById('llmNumInstructions').value
                };

                const response = await fetch('/process_input', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(formData)
                });

                const data = await response.json();
                
                if (data.error) {
                    alert('Error: ' + data.error);
                    return;
                }

                // Update console output
                document.getElementById('consoleOutput').innerHTML = data.console_output;
                
                // Update match plots
                const plotsContainer = document.getElementById('instructionMatchPlots');
                plotsContainer.innerHTML = '';
                if (data.matchPlots && data.matchPlots.length > 0) {
                    data.matchPlots.forEach(plotPath => {
                        const img = document.createElement('img');
                        img.src = '/' + plotPath;
                        img.style.maxWidth = '100%';
                        img.style.margin = '10px';
                        plotsContainer.appendChild(img);
                    });
                }

                // Show confirmation block
                document.getElementById('confirmationBlock').style.display = 'block';
                
                // Update buttons
                submitBtn.style.display = 'none';
                retryBtn.style.display = 'inline-block';

            } catch (error) {
                console.error('Error processing input:', error);
                alert('An error occurred while processing your input.');
            } finally {
                submitBtn.disabled = false;
                submitBtn.innerHTML = 'Process Instructions';
            }
        }

        // Confirm result
        async function confirmResult(isCorrect) {
            const userInput = document.getElementById('userInput').value;
            const selectedApp = document.getElementById('applicationSelect').value;
            const enableLLMPlanner = document.getElementById('enableLLMPlanner').checked;

            try {
                const response = await fetch('/confirm_result', {
                method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        userInput: userInput,
                        selectedApps: [selectedApp],
                        isCorrect: isCorrect,
                        enableLLMPlanner: enableLLMPlanner,
                        isLLMValidation: false
                    })
                });

                const data = await response.json();
                document.getElementById('confirmationResult').innerHTML = data.message;
                
                // Update instruction count
                updateStatus();

            } catch (error) {
                console.error('Error confirming result:', error);
                alert('An error occurred while confirming the result.');
            }
        }

        // New instruction
        function newInstruction() {
            document.getElementById('userInput').value = '';
            document.getElementById('consoleOutput').innerHTML = '';
            document.getElementById('instructionMatchPlots').innerHTML = '';
            document.getElementById('confirmationResult').innerHTML = '';
            document.getElementById('confirmationBlock').style.display = 'none';
            document.getElementById('submitBtn').style.display = 'inline-block';
            document.getElementById('retryBtn').style.display = 'none';

            fetch('/new_instruction', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ instruction: document.getElementById('userInput').value })
            })
            .then(response => response.json())
            .then(data => {
                console.log('New instruction processed:', data);
            })
            .catch(error => console.error('Error processing new instruction:', error));
        }

        // Start training
        async function startTraining() {
            const selectedApp = document.getElementById('applicationSelect').value;
            if (!selectedApp) {
                alert('Please select an application first.');
                return;
            }
            
            // Check if at least one agent is selected
            const selectedAgents = Array.from(document.querySelectorAll('#agentSelection input[type="checkbox"]:checked')).map(cb => cb.value);
            if (selectedAgents.length === 0) {
                alert('Please select at least one agent to train.');
                return;
            }
            
            const trainBtn = document.getElementById('trainModelBtn');
            const trainingStatus = document.getElementById('trainingStatus');
            
            trainBtn.disabled = true;
            trainingStatus.style.display = 'block';

            try {
                const formData = {
                selectedApps: [selectedApp],
                    localConfigInput: document.getElementById('localConfigSelect').value,
                    observedStateInput: document.getElementById('observedStateSelect').value,
                    selectedPlot: document.getElementById('plotSelect').value,
                    trainingEpisodes: parseInt(document.getElementById('trainingEpisodes').value),
                    trainingRepeats: parseInt(document.getElementById('trainingRepeats').value),
                    testEpisodes: parseInt(document.getElementById('testEpisodes').value),
                    testRepeats: parseInt(document.getElementById('testRepeats').value),
                    selectedAgents: Array.from(document.querySelectorAll('#agentSelection input[type="checkbox"]:checked')).map(cb => cb.value),
                    agent_adapter_dict: getAgentAdapterDict()
                };
                
                console.log('Form data being sent:', formData);

                // Add agent parameters
                const selectedAgents = Array.from(document.querySelectorAll('#agentSelection input[type="checkbox"]:checked')).map(cb => cb.value);
                selectedAgents.forEach(agentId => {
                    if (agentDefinitions[agentId]) {
                        Object.keys(agentDefinitions[agentId].params).forEach(paramKey => {
                            const fieldId = `${agentId}_${paramKey}`;
                            const field = document.getElementById(fieldId);
                            if (field) {
                                if (field.type === 'checkbox') {
                                    formData[fieldId] = field.checked;
                                } else {
                                    formData[fieldId] = field.value;
                        }
                    }
                });
            }
                });

                const response = await fetch('/train_model', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(formData)
                });

                console.log('Training response status:', response.status);
                console.log('Training response headers:', response.headers);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('Training response data:', data);
                
                if (data.job_id) {
                currentJobId = data.job_id;
                    switchTab('results');
                    
                    // Check if there are validated instructions
                    let hasInstructions = false;
                    try {
                        const instructionsResponse = await fetch('/get_correct_instructions');
                        const instructionsData = await instructionsResponse.json();
                        hasInstructions = instructionsData.correctInstructions && instructionsData.correctInstructions.length > 0;
                    } catch (error) {
                        console.log('Could not check instruction status:', error);
                        hasInstructions = false;
                    }
                    
                    // Show training started message
                    const resultsContainer = document.getElementById('varianceResults');
                    resultsContainer.innerHTML = `
                        <div class="loading-message">
                            <p><strong>Training started!</strong></p>
                            <p>Job ID: ${data.job_id}</p>
                            <p><strong>Agents:</strong> ${selectedAgents.join(', ')}</p>
                            <p><strong>Mode:</strong> ${hasInstructions ? 'Instruction-guided + Standard RL' : 'Standard RL only'}</p>
                            <p>Training is running in the background. Results will be automatically refreshed when training completes.</p>
                        </div>
                    `;
                    
                    // Start monitoring the job for completion
                    monitorJobCompletion(data.job_id);
                } else {
                    alert('Error starting training: ' + (data.error || 'Unknown error'));
                }

            } catch (error) {
                console.error('Error starting training:', error);
                console.error('Error details:', error.message);
                console.error('Error stack:', error.stack);
                alert(`An error occurred while starting training: ${error.message}`);
            } finally {
                trainBtn.disabled = false;
                trainingStatus.style.display = 'none';
            }
        }

        // Monitor job completion and refresh results when done
        async function monitorJobCompletion(jobId) {
            const checkInterval = 2000; // Check every 2 seconds
            const maxChecks = 300; // Maximum 10 minutes of checking
            let checkCount = 0;
            
            const checkJobStatus = async () => {
                try {
                    const response = await fetch(`/get_job_status/${jobId}`);
                    const data = await response.json();
                    
                    if (data.status === 'completed') {
                        console.log('Training completed! Refreshing results...');
                        // Refresh the results
                        await loadVarianceResults();
                        return; // Stop monitoring
                    } else if (data.status === 'failed') {
                        console.log('Training failed!');
                        const resultsContainer = document.getElementById('varianceResults');
                        resultsContainer.innerHTML = `
                            <div class="error-message">
                                <p><strong>Training failed!</strong></p>
                                <p>Job ID: ${jobId}</p>
                                <p>Please check the console for error details and try again.</p>
                            </div>
                        `;
                        return; // Stop monitoring
                    }
                    
                    checkCount++;
                    if (checkCount < maxChecks) {
                        setTimeout(checkJobStatus, checkInterval);
                    } else {
                        console.log('Job monitoring timeout reached');
                        const resultsContainer = document.getElementById('varianceResults');
                        resultsContainer.innerHTML = `
                            <div class="loading-message">
                                <p><strong>Training in progress...</strong></p>
                                <p>Job ID: ${jobId}</p>
                                <p>Monitoring timeout reached. Click "Refresh Results" to check for completed results.</p>
                            </div>
                        `;
                    }
                } catch (error) {
                    console.error('Error checking job status:', error);
                    checkCount++;
                    if (checkCount < maxChecks) {
                        setTimeout(checkJobStatus, checkInterval);
                    }
                }
            };
            
            // Start monitoring
            setTimeout(checkJobStatus, checkInterval);
        }

        // Reset all instructions
        async function resetAllInstructions() {
            if (!confirm("Are you sure you want to reset all instructions and their validation states? This action cannot be undone.")) {
                return;
            }
            
            try {
                const response = await fetch('/reset_all_instructions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const data = await response.json();
                if (data.status === 'success') {
                    newInstruction();
                    alert(data.message);
                    updateStatus();
                } else {
                    alert("Failed to reset instructions: " + (data.message || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error resetting instructions:', error);
                alert('An error occurred while trying to reset instructions.');
            }
        }

        // Load data
        async function loadData() {
            try {
                const response = await fetch('/load_data', {
                method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const data = await response.json();
                if (data.status === 'success') {
                    loadApplications();
                    loadAllOptions();
                    updateStatus();
                    alert('Data reloaded successfully.');
                }
            } catch (error) {
                console.error('Error loading data:', error);
                alert('An error occurred while loading data.');
            }
        }

        // Update status
        function updateStatus() {
            document.getElementById('lastUpdate').textContent = new Date().toLocaleString();
        }

        // Export config
        async function exportConfig() {
            const config = {
                application: document.getElementById('applicationSelect').value,
                localConfig: document.getElementById('localConfigSelect').value,
                observedState: document.getElementById('observedStateSelect').value,
                plot: document.getElementById('plotSelect').value,
                trainingEpisodes: document.getElementById('trainingEpisodes').value,
                trainingRepeats: document.getElementById('trainingRepeats').value,
                testEpisodes: document.getElementById('testEpisodes').value,
                testRepeats: document.getElementById('testRepeats').value,
                selectedAgents: Array.from(document.querySelectorAll('#agentSelection input[type="checkbox"]:checked')).map(cb => cb.value),
                llmSettings: {
                    enabled: document.getElementById('enableLLMPlanner').checked,
                    model: document.getElementById('llmModelSelect').value,
                    contextLength: document.getElementById('llmContextLength').value,
                    numInstructions: document.getElementById('llmNumInstructions').value
                }
            };

            try {
                const response = await fetch('/export_config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });

                const data = await response.json();
                if (data.status === 'success') {
                    alert('Configuration exported successfully!');
                    } else {
                    alert('Error exporting configuration: ' + data.message);
                }
            } catch (error) {
                console.error('Error exporting config:', error);
                alert('An error occurred while exporting configuration.');
            }
        }

        // Import config
        async function importConfig(input) {
            const file = input.files[0];
            if (!file) return;

            try {
            const formData = new FormData();
                formData.append('file', file);

                const response = await fetch('/import_config', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();
                if (data.status === 'success') {
                    // Apply the imported configuration
                    const config = data.config;
                    if (config.application) document.getElementById('applicationSelect').value = config.application;
                    if (config.localConfig) document.getElementById('localConfigSelect').value = config.localConfig;
                    if (config.observedState) document.getElementById('observedStateSelect').value = config.observedState;
                    if (config.plot) document.getElementById('plotSelect').value = config.plot;
                    if (config.trainingEpisodes) document.getElementById('trainingEpisodes').value = config.trainingEpisodes;
                    if (config.trainingRepeats) document.getElementById('trainingRepeats').value = config.trainingRepeats;
                    if (config.testEpisodes) document.getElementById('testEpisodes').value = config.testEpisodes;
                    if (config.testRepeats) document.getElementById('testRepeats').value = config.testRepeats;
                    
                    // Update agent checkboxes
                    document.querySelectorAll('#agentSelection input[type="checkbox"]').forEach(cb => {
                        cb.checked = config.selectedAgents && config.selectedAgents.includes(cb.value);
                    });
                    
                    // Update LLM settings
                    if (config.llmSettings) {
                        document.getElementById('enableLLMPlanner').checked = config.llmSettings.enabled || false;
                        if (config.llmSettings.model) document.getElementById('llmModelSelect').value = config.llmSettings.model;
                        if (config.llmSettings.contextLength) document.getElementById('llmContextLength').value = config.llmSettings.contextLength;
                        if (config.llmSettings.numInstructions) document.getElementById('llmNumInstructions').value = config.llmSettings.numInstructions;
                    }
                    
                    alert('Configuration imported successfully!');
                } else {
                    alert('Error importing configuration: ' + data.message);
                }
            } catch (error) {
                console.error('Error importing config:', error);
                alert('An error occurred while importing configuration.');
            }

            // Reset file input
            input.value = '';
        }

        // Refresh applications
        async function refreshApplications() {
            try {
                const response = await fetch('/refresh_application_data', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const data = await response.json();
                if (data.status === 'success') {
                    loadApplications();
                    loadAllApplicationsInfo();
                    alert('Applications refreshed successfully!');
                } else {
                    alert('Error refreshing applications: ' + data.message);
                }
            } catch (error) {
                console.error('Error refreshing applications:', error);
                alert('An error occurred while refreshing applications.');
            }
        }

        // Check all updates
        async function checkAllUpdates() {
            try {
                const response = await fetch('/check_all_application_updates', {
                method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const data = await response.json();
                const updateStatus = document.getElementById('updateStatus');
                
                if (data.has_any_updates) {
                    updateStatus.innerHTML = '<p style="color: orange;">Updates available for some applications.</p>';
                    updateStatus.style.display = 'block';
                } else {
                    updateStatus.innerHTML = '<p style="color: green;">All applications are up to date.</p>';
                    updateStatus.style.display = 'block';
                }
                
                // Refresh the applications info to show updated status
                loadAllApplicationsInfo();
            } catch (error) {
                console.error('Error checking updates:', error);
                alert('An error occurred while checking for updates.');
            }
        }

        // Load config data
        async function loadConfigData() {
            // This function can be expanded to load specific configuration data
            // when a local config is selected
        }

        // Load agent definitions
        async function loadAgentDefinitions() {
            try {
                const response = await fetch('/get_agent_definitions');
                agentDefinitions = await response.json();
                updateAgentConfig();
            } catch (error) {
                console.error('Error loading agent definitions:', error);
            }
        }

        // Load interface guide
        async function loadInterfaceGuide() {
            try {
                const response = await fetch('/get_interface_guide');
                const data = await response.json();
                
                const contentDiv = document.getElementById('interfaceGuideContent');
                if (data.content) {
                    contentDiv.innerHTML = data.content;
                } else if (data.error) {
                    contentDiv.innerHTML = `
                        <div class="error-message">
                            <h3>Welcome to elsciRL</h3>
                            <p>This web application helps you run reinforcement learning experiments with various agents and adapters.</p>
                            <p><strong>Error loading interface guide:</strong> ${data.error}</p>
                            <p>Please check your internet connection or try refreshing the page.</p>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Error loading interface guide:', error);
                const contentDiv = document.getElementById('interfaceGuideContent');
                contentDiv.innerHTML = `
                    <div class="error-message">
                        <h3>Welcome to elsciRL</h3>
                        <p>This web application helps you run reinforcement learning experiments with various agents and adapters.</p>
                        <p><strong>Error loading interface guide:</strong> ${error.message}</p>
                        <p>Please check your internet connection or try refreshing the page.</p>
                    </div>
                `;
            }
        }

        // Load preset instruction options when application changes
        async function loadPresetInstructions() {
            const selectedApp = document.getElementById('applicationSelect').value;
            const presetSelect = document.getElementById('presetSelect');
            const presetDescription = document.getElementById('presetDescription');
            const loadPresetBtn = document.getElementById('loadPresetBtn');
            
            if (!selectedApp) {
                presetSelect.innerHTML = '<option value="">Select an application first...</option>';
                presetDescription.textContent = '';
                loadPresetBtn.disabled = true;
                return;
            }
            
            try {
                const response = await fetch('/get_available_instruction_presets', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ application: selectedApp })
                });
                
                const data = await response.json();
                
                if (data.error) {
                    presetSelect.innerHTML = `<option value="">Error: ${data.error}</option>`;
                    presetDescription.textContent = '';
                    loadPresetBtn.disabled = true;
                    return;
                }
                
                presetSelect.innerHTML = '<option value="">Choose a preset...</option>';
                
                if (data.presets && data.presets.length > 0) {
                    data.presets.forEach(preset => {
                        const option = document.createElement('option');
                        option.value = preset.name;
                        option.textContent = preset.description;
                        presetSelect.appendChild(option);
                    });
                    presetDescription.textContent = `${data.count} preset(s) available for ${selectedApp}`;
                } else {
                    presetSelect.innerHTML = '<option value="">No presets available for this application</option>';
                    presetDescription.textContent = 'No preset instruction plans available for this application.';
                }
                
                loadPresetBtn.disabled = true;
                
            } catch (error) {
                console.error('Error loading preset instructions:', error);
                presetSelect.innerHTML = '<option value="">Error loading presets</option>';
                presetDescription.textContent = 'Error loading preset instructions.';
                loadPresetBtn.disabled = true;
            }
        }

        // Load the selected preset instruction
        async function loadSelectedPreset() {
            const selectedApp = document.getElementById('applicationSelect').value;
            const presetSelect = document.getElementById('presetSelect');
            const presetName = presetSelect.value;
            const userInput = document.getElementById('userInput');
            const clearPresetBtn = document.getElementById('clearPresetBtn');
            
            if (!presetName) return;
            
            try {
                const response = await fetch('/load_instruction_preset', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        application: selectedApp,
                        preset_name: presetName
                    })
                });
                
                const data = await response.json();
                
                if (data.error) {
                    alert(`Error loading preset: ${data.error}`);
                    return;
                }
                
                // Extract instruction text from the preset data
                let instructionText = '';
                if (data.instruction_data && typeof data.instruction_data === 'object') {
                    // Try to find instruction text in the data structure
                    if (data.instruction_data.user_input) {
                        instructionText = data.instruction_data.user_input;
                    } else if (data.instruction_data.instructions) {
                        instructionText = data.instruction_data.instructions.join('\n');
                    } else if (data.instruction_data.description) {
                        instructionText = data.instruction_data.description;
                    } else {
                        // Fallback: convert the whole object to a readable format
                        instructionText = `Preset: ${presetName}\n\n${JSON.stringify(data.instruction_data, null, 2)}`;
                    }
                } else {
                    instructionText = `Preset: ${presetName}\n\n${data.instruction_data}`;
                }
                
                userInput.value = instructionText;
                clearPresetBtn.style.display = 'inline-block';
                
                // Show success message
                const presetDescription = document.getElementById('presetDescription');
                presetDescription.textContent = `✓ Loaded preset: ${presetName}`;
                presetDescription.style.color = '#28a745';
                
            } catch (error) {
                console.error('Error loading preset:', error);
                alert('Error loading preset instruction plan.');
            }
        }

        // Clear the loaded preset
        function clearPreset() {
            const userInput = document.getElementById('userInput');
            const presetSelect = document.getElementById('presetSelect');
            const clearPresetBtn = document.getElementById('clearPresetBtn');
            const presetDescription = document.getElementById('presetDescription');
            
            userInput.value = '';
            presetSelect.value = '';
            clearPresetBtn.style.display = 'none';
            presetDescription.textContent = '';
        }

        // Handle preset selection change
        function onPresetSelectChange() {
            const presetSelect = document.getElementById('presetSelect');
            const loadPresetBtn = document.getElementById('loadPresetBtn');
            
            if (presetSelect.value) {
                loadPresetBtn.disabled = false;
            } else {
                loadPresetBtn.disabled = true;
            }
        }

        // Load application overview
        async function loadApplicationOverview() {
            try {
                const response = await fetch('/get_all_applications_info');
                const data = await response.json();
                
                const contentDiv = document.getElementById('applicationOverviewContent');
                if (data.applications && data.applications.length > 0) {
                    let html = '<div class="applications-overview">';
                    
                    // Filter to only show downloaded applications
                    const downloadedApps = data.applications.filter(app => app.is_downloaded);
                    
                    if (downloadedApps.length > 0) {
                        html += '<h3>Downloaded Applications</h3>';
                        html += '<div class="app-grid">';
                        downloadedApps.forEach(app => {
                            html += `
                                <div class="app-card" onclick="selectApplication('${app.name}', this)">
                                    <h4>${app.name}</h4>
                                    <div class="app-details">
                                        <p><strong>Status:</strong> ${app.has_updates ? '🔄 Updates available' : '✅ Up to date'}</p>
                                        <p><strong>Components:</strong> ${app.adapters_count} adapters, ${app.configs_count} configs, ${app.experiment_configs_count} experiments</p>
                                        ${app.has_prerender_data ? '<p><strong>Prerender Data:</strong> ✅ Available</p>' : ''}
                                        ${app.has_instructions ? '<p><strong>Instructions:</strong> ✅ Available</p>' : ''}
                                        ${app.has_analysis ? '<p><strong>Analysis:</strong> ✅ Available</p>' : ''}
                                        ${app.last_updated ? `<p><strong>Last Updated:</strong> ${formatTimestamp(app.last_updated)}</p>` : ''}
                                    </div>
                                </div>
                            `;
                        });
                        html += '</div>';
                    }
                    
                    // Add configuration selection section
                    html += `
                        <div id="applicationConfigSection" style="display: none; margin-top: 30px;">
                            <h3>Configuration Selection</h3>
                            <div class="config-selection-grid">
                                <!-- Local Config Selection -->
                                <div class="config-selection-card">
                                    <h4>Local Configuration</h4>
                                    <div id="overviewLocalConfigOptions" class="config-options-container">
                                        <p style="color: #666; font-style: italic;">Select an application to see available configurations</p>
                                    </div>
                                </div>
                                
                                <!-- Analysis Plot Selection -->
                                <div class="config-selection-card">
                                    <h4>Analysis Plot</h4>
                                    <div id="overviewPlotOptions" class="config-options-container">
                                        <p style="color: #666; font-style: italic;">Select an application to see available plots</p>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Selected Configuration Summary -->
                            <div id="overviewConfigSummary" style="display: none; padding: 15px; background-color: #f8f9fa; border-radius: 8px; border: 1px solid var(--border-color);">
                                <div id="overviewSelectedConfigs" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px;">
                                    <div id="overviewLocalConfigSummary" style="padding: 15px; background-color: white; border-radius: 8px; border: 1px solid var(--border-color); box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                                        <h5 style="margin: 0 0 10px 0; color: var(--button-color); font-size: 1.1em; display: flex; align-items: center;">
                                            <span style="margin-right: 8px;">⚙️</span>Local Configuration
                                        </h5>
                                        <div id="overviewLocalConfigValue" style="color: #333; font-size: 1.2em; font-weight: 500; margin-bottom: 8px; padding: 8px; background-color: #f8f9fa; border-radius: 4px; border-left: 3px solid var(--button-color);">None selected</div>
                                        <div id="overviewLocalConfigContent" style="display: none; margin-top: 10px;">
                                            <div style="color: #666; font-size: 0.9em; margin-bottom: 8px;">Configuration Details:</div>
                                            <pre id="overviewLocalConfigJson" style="background-color: #f8f9fa; border: 1px solid #e9ecef; border-radius: 4px; padding: 12px; font-size: 0.85em; color: #333; overflow-x: auto; max-height: 300px; overflow-y: auto; white-space: pre-wrap; word-wrap: break-word;"></pre>
                                        </div>
                                        <div style="color: #666; font-size: 0.9em;">Configuration file for the selected application</div>
                                    </div>
                                    <div id="overviewPlotSummary" style="padding: 15px; background-color: white; border-radius: 8px; border: 1px solid var(--border-color); box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                                        <h5 style="margin: 0 0 10px 0; color: var(--button-color); font-size: 1.1em; display: flex; align-items: center;">
                                            <span style="margin-right: 8px;">📊</span>Analysis Plot
                                        </h5>
                                        <div id="overviewPlotValue" style="color: #333; font-size: 1.2em; font-weight: 500; margin-bottom: 8px; padding: 8px; background-color: #f8f9fa; border-radius: 4px; border-left: 3px solid var(--button-color);">None selected</div>
                                        <div style="color: #666; font-size: 0.9em;">Visualization type for analysis results</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    // Add selected application details section
                    html += `
                        <div id="selectedApplicationDetails" style="display: none;">
                            <h3>Selected Application Details</h3>
                            <div id="selectedAppContent">
                                <p>Select an application to view details, prerender image, and README.</p>
                    </div>
                </div>
            `;
            
                    html += '</div>';
                    contentDiv.innerHTML = html;
                } else {
                    contentDiv.innerHTML = '<p>No applications available.</p>';
                }
            } catch (error) {
                console.error('Error loading application overview:', error);
                const contentDiv = document.getElementById('applicationOverviewContent');
                contentDiv.innerHTML = `
                    <div class="error-message">
                        <p><strong>Error loading application overview:</strong> ${error.message}</p>
                        <p>Please try refreshing the page.</p>
                    </div>
                `;
            }
        }

        // Configuration selection functions
        function showConfigDropdown(configType) {
            // Hide all other dropdowns
            document.querySelectorAll('.config-dropdown').forEach(dropdown => {
                dropdown.classList.remove('show');
            });
            
            // Show the selected dropdown
            const dropdown = document.getElementById(configType + 'Dropdown');
            if (dropdown) {
                dropdown.classList.add('show');
            }
        }

        function hideConfigDropdown(configType) {
            const dropdown = document.getElementById(configType + 'Dropdown');
            if (dropdown) {
                dropdown.classList.remove('show');
            }
        }

        function applyConfig(configType) {
            const selectElement = document.getElementById(configType + 'Select');
            const selectedValue = selectElement.value;
            const displayElement = document.getElementById('selected' + configType.charAt(0).toUpperCase() + configType.slice(1));
            
            if (selectedValue) {
                displayElement.textContent = `${configType.charAt(0).toUpperCase() + configType.slice(1)}: ${selectedValue}`;
                
                // Update the main application form if it exists
                updateMainApplicationForm(configType, selectedValue);
            }
            
            // Hide the dropdown
            hideConfigDropdown(configType);
        }

        function updateMainApplicationForm(configType, selectedValue) {
            // Update the main application form dropdowns
            if (configType === 'localConfig') {
                const localConfigSelect = document.getElementById('localConfigInput');
                if (localConfigSelect) {
                    localConfigSelect.value = selectedValue;
                }
            } else if (configType === 'observedStates') {
                const observedStatesSelect = document.getElementById('observedStateInput');
                if (observedStatesSelect) {
                    observedStatesSelect.value = selectedValue;
                }
            } else if (configType === 'plotOptions') {
                const plotSelect = document.getElementById('selectedPlot');
                if (plotSelect) {
                    plotSelect.value = selectedValue;
                }
            }
        }

        async function loadApplicationConfigurations(applicationName) {
            try {
                // Show loading state
                const configButtons = document.querySelectorAll('.config-button');
                configButtons.forEach(button => {
                    button.disabled = true;
                    button.textContent = 'Loading...';
                });
                
                // Load local configs
                const localConfigsResponse = await fetch('/get_local_configs', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ application: applicationName })
                });
                const localConfigsData = await localConfigsResponse.json();
                
                const localConfigSelect = document.getElementById('localConfigSelect');
                if (localConfigSelect && localConfigsData.localConfigs[applicationName]) {
                    localConfigSelect.innerHTML = '<option value="">Select a local config...</option>';
                    localConfigsData.localConfigs[applicationName].forEach(config => {
                        localConfigSelect.innerHTML += `<option value="${config}">${config}</option>`;
                    });
                } else {
                    localConfigSelect.innerHTML = '<option value="">No local configs available</option>';
                }

                // Load observed states
                const observedStatesResponse = await fetch('/get_observed_states', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ applications: [applicationName] })
                });
                const observedStatesData = await observedStatesResponse.json();
                
                const observedStatesSelect = document.getElementById('observedStatesSelect');
                if (observedStatesSelect && observedStatesData.observedStates[applicationName]) {
                    observedStatesSelect.innerHTML = '<option value="">Select observed states...</option>';
                    observedStatesData.observedStates[applicationName].forEach(state => {
                        observedStatesSelect.innerHTML += `<option value="${state}">${state}</option>`;
                    });
                } else {
                    observedStatesSelect.innerHTML = '<option value="">No observed states available</option>';
                }

                // Load plot options
                const plotOptionsResponse = await fetch('/get_plot_options', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ application: applicationName })
                });
                const plotOptionsData = await plotOptionsResponse.json();
                
                const plotOptionsSelect = document.getElementById('plotOptionsSelect');
                if (plotOptionsSelect && plotOptionsData.plotOptions[applicationName]) {
                    plotOptionsSelect.innerHTML = '<option value="">Select a plot option...</option>';
                    plotOptionsData.plotOptions[applicationName].forEach(plot => {
                        plotOptionsSelect.innerHTML += `<option value="${plot}">${plot}</option>`;
                    });
                } else {
                    plotOptionsSelect.innerHTML = '<option value="">No plot options available</option>';
                }

                // Restore button states
                const configButtonsRestore = document.querySelectorAll('.config-button');
                configButtonsRestore.forEach(button => {
                    button.disabled = false;
                });
                
                // Restore specific button text
                const localConfigBtn = document.querySelector('button[onclick="showConfigDropdown(\'localConfig\')"]');
                const observedStatesBtn = document.querySelector('button[onclick="showConfigDropdown(\'observedStates\')"]');
                const plotOptionsBtn = document.querySelector('button[onclick="showConfigDropdown(\'plotOptions\')"]');
                
                if (localConfigBtn) localConfigBtn.textContent = 'Select Local Config';
                if (observedStatesBtn) observedStatesBtn.textContent = 'Select Observed States';
                if (plotOptionsBtn) plotOptionsBtn.textContent = 'Select Analysis Plot';

            } catch (error) {
                console.error('Error loading application configurations:', error);
                
                // Restore button states even on error
                const configButtonsError = document.querySelectorAll('.config-button');
                configButtonsError.forEach(button => {
                    button.disabled = false;
                });
            }
        }

        function applyAllConfigurations() {
            // Apply all currently selected configurations to the main form
            const localConfigValue = document.getElementById('localConfigSelect').value;
            const observedStatesValue = document.getElementById('observedStatesSelect').value;
            const plotOptionsValue = document.getElementById('plotOptionsSelect').value;
            
            if (localConfigValue) {
                updateMainApplicationForm('localConfig', localConfigValue);
            }
            if (observedStatesValue) {
                updateMainApplicationForm('observedStates', observedStatesValue);
            }
            if (plotOptionsValue) {
                updateMainApplicationForm('plotOptions', plotOptionsValue);
            }
            
            // Show success message
            alert('All selected configurations have been applied to the experiment form!');
        }

        function clearAllConfigurations() {
            // Clear all selected configurations
            document.getElementById('selectedLocalConfigSummary').textContent = 'Local Config: None';
            document.getElementById('selectedObservedStatesSummary').textContent = 'Observed States: None';
            document.getElementById('selectedPlotOptionsSummary').textContent = 'Analysis Plot: None';
            
            // Clear button selections
            document.querySelectorAll('.config-option-button').forEach(button => {
                button.classList.remove('selected');
            });
            
            // Hide clear button and summary
            document.querySelector('.config-clear-btn').style.display = 'none';
            document.getElementById('selectedConfigSummary').style.display = 'none';
        }

        // Load configuration dropdowns
        function loadConfigurationDropdowns(selectedApp, configsData, statesData, plotsData) {
            // Load local configs
            loadConfigDropdown('localConfigSelect', configsData.localConfigs[selectedApp] || []);
            
            // Load observed states
            loadConfigDropdown('observedStateSelect', statesData.observedStates[selectedApp] || []);
            
            // Load plot options
            loadConfigDropdown('plotSelect', plotsData.plotOptions[selectedApp] || []);
        }

        // Load configuration dropdown
        function loadConfigDropdown(selectId, options) {
            const select = document.getElementById(selectId);
            select.innerHTML = '<option value="">Select an option...</option>';
            
            if (options && options.length > 0) {
                options.forEach(option => {
                    const optionElement = document.createElement('option');
                    optionElement.value = option;
                    optionElement.textContent = option;
                    select.appendChild(optionElement);
                });
                
                // Default to first option
                select.selectedIndex = 1; // Index 1 because index 0 is the placeholder
            } else {
                select.innerHTML = '<option value="">No options available</option>';
            }
            
            // Update summary after loading
            updateConfigSummary();
        }

        // Load observed states for instructions tab
        function loadInstructionsObservedStates(selectedApp, statesData) {
            const select = document.getElementById('instructionsObservedStateSelect');
            select.innerHTML = '<option value="">Select an option...</option>';
            
            const states = statesData.observedStates[selectedApp] || [];
            
            if (states.length > 0) {
                states.forEach(state => {
                    const optionElement = document.createElement('option');
                    optionElement.value = state;
                    optionElement.textContent = state;
                    select.appendChild(optionElement);
                });
                
                // Default to first option
                select.selectedIndex = 1; // Index 1 because index 0 is the placeholder
                updateInstructionsObservedStates();
            } else {
                select.innerHTML = '<option value="">No observed states available</option>';
            }
        }

        // Update instructions observed states display
        function updateInstructionsObservedStates() {
            const selectedState = document.getElementById('instructionsObservedStateSelect').value;
            const summaryElement = document.getElementById('instructionsObservedStatesSummary');
            const infoElement = document.getElementById('instructionsObservedStatesInfo');
            const previewElement = document.getElementById('instructionsObservedStatesPreview');
            const contentElement = document.getElementById('instructionsObservedStatesContent');
            
            if (summaryElement) {
                summaryElement.textContent = selectedState || 'None';
            }
            
            if (infoElement) {
                infoElement.style.display = selectedState ? 'block' : 'none';
            }
            
            // Show/hide preview section
            if (previewElement) {
                previewElement.style.display = selectedState ? 'block' : 'none';
            }
            
            // Fetch and display preview if a state is selected
            if (selectedState) {
                fetchObservedStatesPreview(selectedState);
            } else if (contentElement) {
                contentElement.textContent = '';
            }
            
            // Update the main experiment form dropdown for compatibility
            const mainSelect = document.getElementById('observedStateSelect');
            if (mainSelect) {
                mainSelect.value = selectedState;
            }
        }

        // Fetch observed states preview content
        async function fetchObservedStatesPreview(stateFileName) {
            const selectedApp = document.getElementById('applicationSelect').value;
            if (!selectedApp || !stateFileName) return;

            const contentElement = document.getElementById('instructionsObservedStatesContent');
            if (!contentElement) return;

            // Show loading state
            contentElement.textContent = 'Loading observed states preview...';
            contentElement.style.color = '#666';
            contentElement.style.fontStyle = 'italic';

            try {
                const response = await fetch('/get_observed_states_content', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        application: selectedApp,
                        state_file: stateFileName
                    })
                });

                const data = await response.json();
                
                if (data.error) {
                    console.error('Error fetching observed states content:', data.error);
                    contentElement.textContent = `Error: ${data.error}`;
                    contentElement.style.color = '#dc3545';
                    contentElement.style.fontStyle = 'normal';
                } else {
                    displayObservedStatesPreview(data.content, data.is_encoded || false);
                }
            } catch (error) {
                console.error('Error fetching observed states content:', error);
                contentElement.textContent = 'Failed to load observed states preview';
                contentElement.style.color = '#dc3545';
                contentElement.style.fontStyle = 'normal';
            }
        }

        // Display observed states preview content
        function displayObservedStatesPreview(content, isEncoded = false) {
            const contentElement = document.getElementById('instructionsObservedStatesContent');
            if (!contentElement) return;

            try {
                let previewContent;
                
                if (isEncoded) {
                    // Handle encoded tensor data
                    if (Array.isArray(content)) {
                        if (content.length > 0) {
                            // For encoded data, show first few elements with shape info
                            const firstElement = content[0];
                            const shape = `[${content.length}]`;
                            previewContent = `Encoded Tensor Data (Shape: ${shape})\nFirst element:\n${JSON.stringify(firstElement, null, 2)}`;
                            
                            // If it's a nested array (2D+ tensor), show more info
                            if (Array.isArray(firstElement) && firstElement.length > 0) {
                                previewContent += `\n\nFirst row (${firstElement.length} elements):\n${JSON.stringify(firstElement.slice(0, Math.min(10, firstElement.length)), null, 2)}`;
                                if (firstElement.length > 10) {
                                    previewContent += `\n... (${firstElement.length - 10} more elements)`;
                                }
                            }
                        } else {
                            previewContent = 'Encoded Tensor Data (Empty)';
                        }
                    } else {
                        previewContent = `Encoded Data: ${JSON.stringify(content, null, 2)}`;
                    }
                } else {
                    // Handle regular data
                    if (typeof content === 'string') {
                        const parsed = JSON.parse(content);
                        if (Array.isArray(parsed) && parsed.length > 0) {
                            previewContent = JSON.stringify(parsed[0], null, 2);
                        } else if (typeof parsed === 'object' && parsed !== null) {
                            // Get the first key-value pair
                            const firstKey = Object.keys(parsed)[0];
                            previewContent = JSON.stringify({ [firstKey]: parsed[firstKey] }, null, 2);
                        } else {
                            previewContent = JSON.stringify(parsed, null, 2);
                        }
                    } else if (Array.isArray(content) && content.length > 0) {
                        previewContent = JSON.stringify(content[0], null, 2);
                    } else if (typeof content === 'object' && content !== null) {
                        // Get the first key-value pair
                        const firstKey = Object.keys(content)[0];
                        previewContent = JSON.stringify({ [firstKey]: content[firstKey] }, null, 2);
                    } else {
                        previewContent = JSON.stringify(content, null, 2);
                    }
                }

                contentElement.textContent = previewContent;
                contentElement.style.color = '#333';
                contentElement.style.fontStyle = 'normal';
            } catch (error) {
                console.error('Error formatting observed states preview:', error);
                contentElement.textContent = 'Error formatting preview content';
                contentElement.style.color = '#dc3545';
                contentElement.style.fontStyle = 'normal';
            }
        }

        // Update configuration summary
        function updateConfigSummary() {
            const localConfig = document.getElementById('localConfigSelect').value;
            const observedState = document.getElementById('observedStateSelect').value;
            const plot = document.getElementById('plotSelect').value;
            
            // Update summary display if it exists
            const localConfigSummary = document.getElementById('selectedLocalConfigSummary');
            const observedStatesSummary = document.getElementById('selectedObservedStatesSummary');
            const plotSummary = document.getElementById('selectedPlotOptionsSummary');
            
            if (localConfigSummary) {
                localConfigSummary.textContent = `Local Config: ${localConfig || 'None'}`;
            }
            if (observedStatesSummary) {
                observedStatesSummary.textContent = `Observed States: ${observedState || 'None'}`;
            }
            if (plotSummary) {
                plotSummary.textContent = `Analysis Plot: ${plot || 'None'}`;
            }
        }

        // New button-based configuration functions (for overview tab)
        function loadConfigurationOptions(selectedApp, configsData, statesData, plotsData) {
            // Load local configs
            loadConfigSection('localConfig', configsData.localConfigs[selectedApp] || []);
            
            // Load observed states
            loadConfigSection('observedStates', statesData.observedStates[selectedApp] || []);
            
            // Load plot options
            loadConfigSection('plotOptions', plotsData.plotOptions[selectedApp] || []);
        }

        function loadConfigSection(configType, options) {
            const section = document.getElementById(configType + 'Section');
            const grid = document.getElementById(configType + 'Grid');
            
            if (!options || options.length === 0) {
                section.style.display = 'none';
                return;
            }
            
            section.style.display = 'block';
            grid.innerHTML = '';
            
            options.forEach(option => {
                const button = document.createElement('div');
                button.className = 'config-option-button';
                button.onclick = () => selectConfigOption(configType, option, button);
                
                // Create summary information based on config type
                let title, description, meta;
                switch(configType) {
                    case 'localConfig':
                        title = option;
                        description = `Configuration file for ${option}`;
                        meta = 'Local configuration';
                        break;
                    case 'observedStates':
                        title = option;
                        description = `Observed states data: ${option}`;
                        meta = 'State data';
                        break;
                    case 'plotOptions':
                        title = option;
                        description = `Analysis plot: ${option}`;
                        meta = 'Visualization';
                        break;
                }
                
                button.innerHTML = `
                    <div class="config-option-title">${title}</div>
                    <div class="config-option-description">${description}</div>
                    <div class="config-option-meta">${meta}</div>
                `;
                
                grid.appendChild(button);
            });
        }

        function selectConfigOption(configType, option, buttonElement) {
            // Remove selection from other buttons in the same section
            const section = buttonElement.closest('.config-option-grid');
            section.querySelectorAll('.config-option-button').forEach(btn => {
                btn.classList.remove('selected');
            });
            
            // Select this button
            buttonElement.classList.add('selected');
            
            // Update summary
            const summaryElement = document.getElementById('selected' + configType.charAt(0).toUpperCase() + configType.slice(1) + 'Summary');
            summaryElement.textContent = `${configType.charAt(0).toUpperCase() + configType.slice(1)}: ${option}`;
            
            // Show summary and clear button
            document.getElementById('selectedConfigSummary').style.display = 'block';
            document.querySelector('.config-clear-btn').style.display = 'inline-block';
            
            // Update the hidden form fields for compatibility
            updateHiddenFormFields(configType, option);
        }

        function updateHiddenFormFields(configType, option) {
            // Update hidden form fields for compatibility with existing code
            if (configType === 'localConfig') {
                const hiddenSelect = document.getElementById('localConfigSelect');
                if (hiddenSelect) {
                    hiddenSelect.value = option;
                }
            } else if (configType === 'observedStates') {
                const hiddenSelect = document.getElementById('observedStateSelect');
                if (hiddenSelect) {
                    hiddenSelect.value = option;
                }
            } else if (configType === 'plotOptions') {
                const hiddenSelect = document.getElementById('plotSelect');
                if (hiddenSelect) {
                    hiddenSelect.value = option;
                }
            }
        }

        // Simple markdown parser for README content
        function parseMarkdown(markdown) {
            return markdown
                // Headers
                .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                // Bold
                .replace(/\*\*(.*)\*\*/gim, '<strong>$1</strong>')
                .replace(/__(.*)__/gim, '<strong>$1</strong>')
                // Italic
                .replace(/\*(.*)\*/gim, '<em>$1</em>')
                .replace(/_(.*)_/gim, '<em>$1</em>')
                // Code blocks
                .replace(/```([\s\S]*?)```/gim, '<pre><code>$1</code></pre>')
                .replace(/`([^`]*)`/gim, '<code>$1</code>')
                // Links
                .replace(/\[([^\]]*)\]\(([^)]*)\)/gim, '<a href="$2" target="_blank">$1</a>')
                // Line breaks
                .replace(/\n\n/gim, '</p><p>')
                .replace(/\n/gim, '<br>')
                // Wrap in paragraphs
                .replace(/^(.*)$/gim, '<p>$1</p>')
                // Clean up empty paragraphs
                .replace(/<p><\/p>/gim, '')
                .replace(/<p><br><\/p>/gim, '');
        }

        // Format timestamp for display
        function formatTimestamp(timestamp) {
            if (!timestamp) return '';
            
            try {
                // Handle both Unix timestamp (number) and ISO string formats
                let date;
                if (typeof timestamp === 'number') {
                    // Unix timestamp (seconds)
                    date = new Date(timestamp * 1000);
                } else if (typeof timestamp === 'string') {
                    // ISO string format
                    date = new Date(timestamp);
                            } else {
                    return '';
                }
                
                // Check if date is valid
                if (isNaN(date.getTime())) {
                    return '';
                }
                
                // Format as readable date and time
                return date.toLocaleString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
            } catch (error) {
                console.error('Error formatting timestamp:', error);
                return '';
            }
        }

        // Select application and load its details
        async function selectApplication(applicationName, eventElement = null) {
            try {
                const selectedAppDiv = document.getElementById('selectedApplicationDetails');
                const selectedAppContent = document.getElementById('selectedAppContent');
                const configSection = document.getElementById('applicationConfigSection');
                
                // Remove previous selection
                document.querySelectorAll('.app-card').forEach(card => {
                    card.classList.remove('selected');
                });
                
                // Add selection to clicked card
                if (eventElement) {
                    eventElement.classList.add('selected');
                } else {
                    // Find the card by application name if eventElement not provided
                    const cards = document.querySelectorAll('.app-card');
                    cards.forEach(card => {
                        const cardTitle = card.querySelector('h4');
                        if (cardTitle && cardTitle.textContent === applicationName) {
                            card.classList.add('selected');
                        }
                    });
                }
                
                // Update the application dropdown in the Experiment block
                const applicationSelect = document.getElementById('applicationSelect');
                if (applicationSelect) {
                    applicationSelect.value = applicationName;
                    // Trigger the change event to load application data
                    loadApplicationData();
                }
                
                // Show configuration section and load options
                configSection.style.display = 'block';
                await loadOverviewConfigurationOptions(applicationName);
                
                // Show loading state
                selectedAppContent.innerHTML = '<div class="loading-message"><p>Loading application details...</p></div>';
                selectedAppDiv.style.display = 'block';
                
                // Fetch prerender image and README
                const [imageResponse, readmeResponse] = await Promise.all([
                    fetch('/get_prerender_image', {
                    method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ application: applicationName })
                    }),
                    fetch('/get_application_readme', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ application: applicationName })
                    })
                ]);
                
                const imageData = await imageResponse.json();
                const readmeData = await readmeResponse.json();
                
                let html = `<h4>${applicationName}</h4>`;
                
                // Add prerender image if available
                if (imageData.imagePaths && imageData.imagePaths.length > 0) {
                    html += '<div class="prerender-image-section">';
                    html += '<h5>Prerender Image</h5>';
                    imageData.imagePaths.forEach(imagePath => {
                        html += `<img src="/${imagePath}" alt="Prerender image for ${applicationName}" class="prerender-image">`;
                    });
                    html += '</div>';
                } else {
                    html += '<div class="prerender-image-section">';
                    html += '<h5>Prerender Image</h5>';
                    html += '<p>No prerender image available for this application.</p>';
                    html += '</div>';
                }
                
                // Add README if available
                if (readmeData.readme_content) {
                    html += '<div class="readme-section">';
                    html += `<h5>README (${readmeData.readme_name})</h5>`;
                    html += '<div class="readme-content">';
                    // Convert markdown to HTML using a simple markdown parser
                    const markdownHtml = parseMarkdown(readmeData.readme_content);
                    html += markdownHtml;
                    html += '</div>';
                    html += '</div>';
                        } else {
                    html += '<div class="readme-section">';
                    html += '<h5>README</h5>';
                    html += '<p>No README available for this application.</p>';
                    html += '</div>';
                }
                
                
                selectedAppContent.innerHTML = html;
                
            } catch (error) {
                console.error('Error loading application details:', error);
                const selectedAppContent = document.getElementById('selectedAppContent');
                selectedAppContent.innerHTML = `
                    <div class="error-message">
                        <p><strong>Error loading application details:</strong> ${error.message}</p>
                        <p>Please try again.</p>
                    </div>
                `;
            }
        }

        // Update agent configuration forms
        function updateAgentConfig() {
            const container = document.getElementById('agentConfigContainer');
            container.innerHTML = '';

            // Get selected agents
            const selectedAgents = Array.from(document.querySelectorAll('#agentSelection input[type="checkbox"]:checked'))
                .map(cb => cb.value);

            selectedAgents.forEach(agentId => {
                if (agentDefinitions[agentId]) {
                    const agentDef = agentDefinitions[agentId];
                    const agentDiv = document.createElement('div');
                    agentDiv.className = 'config-group';
                    agentDiv.innerHTML = `<h3>${agentDef.display_name} Configuration</h3>`;
                    
                    const paramsDiv = document.createElement('div');
                    paramsDiv.className = 'agent-params';
                    
                    Object.entries(agentDef.params).forEach(([paramKey, paramConfig]) => {
                        const paramDiv = document.createElement('div');
                        paramDiv.className = 'input-group';
                        
                        const fieldId = `${agentId}_${paramKey}`;
                        let inputHtml = '';
                        
                        if (paramConfig.type === 'number') {
                            inputHtml = `
                                <label for="${fieldId}">${paramConfig.label}:</label>
                                <input type="number" id="${fieldId}" 
                                       min="${paramConfig.min || ''}" 
                                       max="${paramConfig.max || ''}" 
                                       step="${paramConfig.step || ''}" 
                                       value="${paramConfig.default || ''}">
                            `;
                        } else if (paramConfig.type === 'text') {
                            inputHtml = `
                                <label for="${fieldId}">${paramConfig.label}:</label>
                                <input type="text" id="${fieldId}" value="${paramConfig.default || ''}">
                            `;
                        } else if (paramConfig.type === 'textarea') {
                            inputHtml = `
                                <label for="${fieldId}">${paramConfig.label}:</label>
                                <textarea id="${fieldId}" rows="${paramConfig.rows || 3}" 
                                          placeholder="${paramConfig.placeholder || ''}">${paramConfig.default || ''}</textarea>
                            `;
                        } else if (paramConfig.type === 'checkbox') {
                            inputHtml = `
                                <div class="checkbox-container">
                                    <input type="checkbox" id="${fieldId}" ${paramConfig.default ? 'checked' : ''}>
                                    <label for="${fieldId}">${paramConfig.label}</label>
                                </div>
                            `;
                        }
                        
                        paramDiv.innerHTML = inputHtml;
                        paramsDiv.appendChild(paramDiv);
                    });
                    
                    agentDiv.appendChild(paramsDiv);
                    container.appendChild(agentDiv);
                }
            });

            // Also update adapter selection when agent config changes
            updateAdapterSelection();
        }

        // Update adapter selection
        function updateAdapterSelection() {
            const container = document.getElementById('adapterSelection');
            container.innerHTML = '';

            // Get selected agents
            const selectedAgents = Array.from(document.querySelectorAll('#agentSelection input[type="checkbox"]:checked'))
                .map(cb => cb.value);

            // Check if application is selected
            const selectedApp = document.getElementById('applicationSelect').value;

            if (!selectedApp) {
                container.innerHTML = '<p>Select an application first to see available adapters.</p>';
                return;
            }

            if (selectedAgents.length === 0) {
                container.innerHTML = '<p>Select at least one agent to configure adapters.</p>';
                return;
            }

            if (availableAdapters.length === 0) {
                container.innerHTML = '<p>No adapters available for the selected application.</p>';
                return;
            }

            selectedAgents.forEach(agentId => {
                const agentDiv = document.createElement('div');
                agentDiv.className = 'agent-adapter-group';
                agentDiv.innerHTML = `
                    <h4>${agentDefinitions[agentId]?.display_name || agentId} Adapters</h4>
                    <div class="adapter-checkboxes" id="adapters_${agentId}">
                        ${availableAdapters.map((adapter, index) => `
                            <div class="checkbox-container">
                                <input type="checkbox" id="${agentId}_${adapter}" value="${adapter}" ${index === 0 ? 'checked' : ''}>
                                <label for="${agentId}_${adapter}">${adapter}</label>
                            </div>
                        `).join('')}
                    </div>
                `;
                container.appendChild(agentDiv);
            });
        }

        // Get agent adapter dictionary for training
        function getAgentAdapterDict() {
            const agentAdapterDict = {};
            const selectedAgents = Array.from(document.querySelectorAll('#agentSelection input[type="checkbox"]:checked'))
                .map(cb => cb.value);

            selectedAgents.forEach(agentId => {
                const adapterCheckboxes = document.querySelectorAll(`#adapters_${agentId} input[type="checkbox"]:checked`);
                agentAdapterDict[agentId] = Array.from(adapterCheckboxes).map(cb => cb.value);
            });

            return agentAdapterDict;
        }

        // Load variance results from uploads directory
        async function loadVarianceResults() {
            try {
                const response = await fetch('/get_variance_results');
                const data = await response.json();
                
                const resultsContainer = document.getElementById('varianceResults');
                
                if (data.error) {
                    resultsContainer.innerHTML = `
                        <div class="error-message">
                            <p><strong>Error loading results:</strong> ${data.error}</p>
                        </div>
                    `;
                    return;
                }
                
                if (!data.results || data.results.length === 0) {
                    resultsContainer.innerHTML = `
                        <div class="no-results-message">
                            <p>No variance analysis results found in the uploads directory.</p>
                            <p>Run a training experiment to generate variance analysis plots.</p>
                        </div>
                    `;
                return;
                }
                
                let html = `<div class="variance-results-grid">`;
                
                data.results.forEach(result => {
                    const modifiedDate = new Date(result.modified * 1000).toLocaleString();
                    const fileSizeKB = Math.round(result.size / 1024);
                    
                    html += `
                        <div class="variance-result-card">
                            <h4>${result.analysis_type}</h4>
                            <img src="/${result.path}" alt="${result.analysis_type}" onclick="openImageModal('/${result.path}')">
                            <div class="variance-result-info">
                                <p><strong>File:</strong> ${result.filename}</p>
                                <p><strong>Generated:</strong> ${modifiedDate}</p>
                                <p><strong>Size:</strong> ${fileSizeKB} KB</p>
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
                resultsContainer.innerHTML = html;
                
            } catch (error) {
                console.error('Error loading variance results:', error);
                const resultsContainer = document.getElementById('varianceResults');
                resultsContainer.innerHTML = `
                    <div class="error-message">
                        <p><strong>Error loading variance results:</strong> ${error.message}</p>
                        <p>Please try again.</p>
                    </div>
                `;
            }
        }

        // Load configuration options for the overview tab
        async function loadOverviewConfigurationOptions(applicationName) {
            try {
                // Load configuration data (excluding observed states)
                const [configsRes, plotsRes] = await Promise.all([
                    fetch('/get_local_configs', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ application: applicationName })
                    }),
                    fetch('/get_plot_options', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ application: applicationName })
                    })
                ]);

                const [configsData, plotsData] = await Promise.all([
                    configsRes.json(),
                    plotsRes.json()
                ]);

                // Load local configs
                loadOverviewConfigSection('overviewLocalConfigOptions', 'localConfig', configsData.localConfigs[applicationName] || []);
                
                // Load plot options
                loadOverviewConfigSection('overviewPlotOptions', 'plotOptions', plotsData.plotOptions[applicationName] || []);
                
                // Auto-select first options if available
                const localConfigs = configsData.localConfigs[applicationName] || [];
                const plotOptions = plotsData.plotOptions[applicationName] || [];
                
                if (localConfigs.length > 0) {
                    // Select first local config
                    const firstConfig = localConfigs[0];
                    updateOverviewConfigDisplay('localConfig', firstConfig);
                    updateHiddenFormFields('localConfig', firstConfig);
                    fetchConfigContent(firstConfig);
                }
                
                if (plotOptions.length > 0) {
                    // Select first plot option
                    const firstPlot = plotOptions[0];
                    updateOverviewConfigDisplay('plotOptions', firstPlot);
                    updateHiddenFormFields('plotOptions', firstPlot);
                } else {
                    // Clear plot selection if no options available
                    updateOverviewConfigDisplay('plotOptions', '');
                    updateHiddenFormFields('plotOptions', '');
                }
                
                // Show summary section if there are any configurations available
                const hasConfigs = localConfigs.length > 0 || plotOptions.length > 0;
                if (hasConfigs) {
                    document.getElementById('overviewConfigSummary').style.display = 'block';
                }

            } catch (error) {
                console.error('Error loading overview configuration options:', error);
            }
        }

        // Load configuration section for overview
        function loadOverviewConfigSection(containerId, configType, options) {
            const container = document.getElementById(containerId);
            
            if (!options || options.length === 0) {
                container.innerHTML = '<p style="color: #666; font-style: italic;">No options available</p>';
                return;
            }
            
            let html = '<div style="display: flex; flex-wrap: wrap; gap: 8px;">';
            
            options.forEach((option, index) => {
                // Add 'selected' class to the first option
                const selectedClass = index === 0 ? ' selected' : '';
                html += `
                    <button class="config-option-btn${selectedClass}" 
                            onclick="selectOverviewConfig('${configType}', '${option}', this)">
                        ${option}
                    </button>
                `;
            });
            
            html += '</div>';
            container.innerHTML = html;
        }

        // Select configuration option in overview
        function selectOverviewConfig(configType, option, buttonElement) {
            // Remove selection from other buttons in the same section
            const container = buttonElement.parentElement;
            container.querySelectorAll('.config-option-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            
            // Select this button
            buttonElement.classList.add('selected');
            
            // Update summary with pretty format
            updateOverviewConfigDisplay(configType, option);
            
            // Show summary section
            document.getElementById('overviewConfigSummary').style.display = 'block';
            
            // If it's a local config, fetch and display the JSON content
            if (configType === 'localConfig') {
                fetchConfigContent(option);
            }
            
            // Update the hidden form fields for compatibility (only for localConfig and plotOptions)
            if (configType === 'localConfig' || configType === 'plotOptions') {
                updateHiddenFormFields(configType, option);
            }
        }

        // Fetch configuration content from backend
        async function fetchConfigContent(configName) {
            const selectedApp = document.getElementById('applicationSelect').value;
            if (!selectedApp || !configName) return;

            // Show loading state
            const contentDiv = document.getElementById('overviewLocalConfigContent');
            const jsonPre = document.getElementById('overviewLocalConfigJson');
            
            if (contentDiv && jsonPre) {
                contentDiv.style.display = 'block';
                jsonPre.textContent = 'Loading configuration...';
                jsonPre.style.color = '#666';
                jsonPre.style.fontStyle = 'italic';
            }

            try {
                const response = await fetch('/get_local_config_content', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        application: selectedApp,
                        config: configName
                    })
                });

                const data = await response.json();
                
                if (data.error) {
                    console.error('Error fetching config content:', data.error);
                    displayConfigError(data.error);
                } else {
                    displayConfigContent(data.config);
                }
            } catch (error) {
                console.error('Error fetching config content:', error);
                displayConfigError('Failed to load configuration content');
            }
        }

        // Display configuration content
        function displayConfigContent(configData) {
            const contentDiv = document.getElementById('overviewLocalConfigContent');
            const jsonPre = document.getElementById('overviewLocalConfigJson');
            
            if (contentDiv && jsonPre) {
                // Format JSON with proper indentation
                const formattedJson = JSON.stringify(configData, null, 2);
                jsonPre.textContent = formattedJson;
                jsonPre.style.color = '#333';
                jsonPre.style.fontStyle = 'normal';
                contentDiv.style.display = 'block';
            }
        }

        // Display configuration error
        function displayConfigError(errorMessage) {
            const contentDiv = document.getElementById('overviewLocalConfigContent');
            const jsonPre = document.getElementById('overviewLocalConfigJson');
            
            if (contentDiv && jsonPre) {
                jsonPre.textContent = `Error: ${errorMessage}`;
                jsonPre.style.color = '#dc3545';
                contentDiv.style.display = 'block';
            }
        }

        // Update overview configuration display with pretty format
        function updateOverviewConfigDisplay(configType, option) {
            if (configType === 'localConfig') {
                const valueElement = document.getElementById('overviewLocalConfigValue');
                const contentDiv = document.getElementById('overviewLocalConfigContent');
                
                if (valueElement) {
                    valueElement.textContent = option;
                    valueElement.style.color = 'var(--button-color)';
                    valueElement.style.backgroundColor = '#e3f2fd';
                    valueElement.style.borderLeftColor = 'var(--button-color)';
                }
                
                // Hide content div initially, it will be shown when content is loaded
                if (contentDiv) {
                    contentDiv.style.display = 'none';
                }
            } else if (configType === 'plotOptions') {
                const valueElement = document.getElementById('overviewPlotValue');
                if (valueElement) {
                    if (option) {
                        valueElement.textContent = option;
                        valueElement.style.color = 'var(--button-color)';
                        valueElement.style.backgroundColor = '#e3f2fd';
                        valueElement.style.borderLeftColor = 'var(--button-color)';
                    } else {
                        // Clear the display when no option is selected
                        valueElement.textContent = 'None selected';
                        valueElement.style.color = '#666';
                        valueElement.style.backgroundColor = '#f8f9fa';
                        valueElement.style.borderLeftColor = 'var(--button-color)';
                    }
                }
            }
        }

        // Reset overview configuration display
        function resetOverviewConfigDisplay() {
            const localConfigValue = document.getElementById('overviewLocalConfigValue');
            const plotValue = document.getElementById('overviewPlotValue');
            const contentDiv = document.getElementById('overviewLocalConfigContent');
            
            if (localConfigValue) {
                localConfigValue.textContent = 'None selected';
                localConfigValue.style.color = '#666';
                localConfigValue.style.backgroundColor = '#f8f9fa';
                localConfigValue.style.borderLeftColor = 'var(--button-color)';
            }
            if (plotValue) {
                plotValue.textContent = 'None selected';
                plotValue.style.color = '#666';
                plotValue.style.backgroundColor = '#f8f9fa';
                plotValue.style.borderLeftColor = 'var(--button-color)';
            }
            
            // Hide JSON content
            if (contentDiv) {
                contentDiv.style.display = 'none';
            }
            
            // Hide summary section
            const summarySection = document.getElementById('overviewConfigSummary');
            if (summarySection) {
                summarySection.style.display = 'none';
            }
        }

        // Open image in modal for better viewing
        function openImageModal(imagePath) {
            // Create modal overlay
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
                cursor: pointer;
            `;
            
            // Create image
            const img = document.createElement('img');
            img.src = imagePath;
            img.style.cssText = `
                max-width: 90%;
                max-height: 90%;
                border-radius: 8px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            `;
            
            // Close modal on click
            modal.onclick = () => document.body.removeChild(modal);
            
            modal.appendChild(img);
            document.body.appendChild(modal);
        }
    </script>
</body>
</html>
